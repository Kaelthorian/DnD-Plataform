<!doctype html>
  <html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Interactive DnD Sheet</title>
    <style>
      :root {
        color-scheme: light;
        --bg: #f4f1ea;
        --fg: #2b1f17;
        --accent: #b84a2d;
        --panel: #fff7ee;
        --line: #2b1f17;
        --muted: #6b584a;
        --grid-cell: 156.499px;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Georgia", "Times New Roman", serif;
        background:
          radial-gradient(circle at 15% 10%, #fdf6ea 0%, transparent 45%),
          radial-gradient(circle at 85% 5%, #f7e6d1 0%, transparent 50%),
          var(--bg);
        color: var(--fg);
      }
      .page {
        max-width: 1200px;
        margin: 24px auto 60px;
        padding: 0 16px 32px;
      }
      .title {
        text-align: center;
        font-size: clamp(2rem, 3vw, 2.8rem);
        letter-spacing: 0.12em;
        text-transform: uppercase;
        margin: 8px 0 18px;
      }
      .layout {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 18px;
        align-items: start;
        justify-items: center;
      }
      .sheet {
        background: var(--panel);
        border: 2px solid var(--line);
        border-radius: 18px;
        padding: 18px;
        box-shadow: 0 18px 40px rgba(43, 31, 23, 0.18);
        width: calc((var(--grid-cell) * 6) + (12px * 5) + 36px);
        max-width: 100%;
      }
      .header-grid {
        position: relative;
      }
      .grid-debug {
        position: absolute;
        inset: 0;
        display: grid;
        grid-template-columns: var(--grid-cell) calc(var(--grid-cell) * 1.05) repeat(4, var(--grid-cell));
        grid-template-rows: calc(var(--grid-cell) / 3) calc(var(--grid-cell) / 3) repeat(12, calc(var(--grid-cell) / 2)) calc(var(--grid-cell) / 3) repeat(25, var(--grid-cell));
        gap: 12px;
        pointer-events: none;
        font-size: 10px;
        color: rgba(107, 88, 74, 0.8);
        z-index: 0;
      }
      .grid-debug span {
        display: grid;
        place-items: center;
        border: 1px dashed rgba(107, 88, 74, 0.25);
      }
      .header-grid > .panel,
      .header-grid > .section-stack,
      .header-grid > .ability {
        position: relative;
        z-index: 1;
        width: 100%;
        height: 100%;
        font-size: 0.75rem;
      }
      .stats-column {
        display: grid;
        grid-template-columns: 1fr;
        grid-auto-rows: min-content;
        row-gap: 8px;
        grid-column: 2 / 3;
        grid-row: 7 / 15;
      }
      .skills-column {
        grid-column: 2 / 7;
        grid-row: 2 / -1;
      }
      .header-grid {
        display: grid;
        grid-template-columns: var(--grid-cell) calc(var(--grid-cell) * 1.05) repeat(4, var(--grid-cell));
        grid-template-rows: calc(var(--grid-cell) / 3) calc(var(--grid-cell) / 3) repeat(12, calc(var(--grid-cell) / 2)) calc(var(--grid-cell) / 3) repeat(25, var(--grid-cell));
        gap: 12px;
        margin-bottom: 16px;
      }
      .grid-character-name {
        grid-column: 1 / 3;
        grid-row: 1 / 2;
      }
      .grid-class {
        grid-column: 4 / 5;
        grid-row: 1 / 2;
      }
      .grid-armor-class {
        grid-column: 3 / 4;
        grid-row: 3 / 4;
      }
      .grid-initiative {
        grid-column: 4 / 5;
        grid-row: 3 / 4;
        width: 50%;
        justify-self: start;
      }
      .grid-speed {
        grid-column: 6 / 7;
        grid-row: 1 / 2;
      }
      .grid-passive-wisdom {
        grid-column: 1 / 3;
        grid-row: 15 / 16;
      }
      .grid-equipment {
        grid-column: 3 / 5;
        grid-row: 5 / 12;
      }
      .grid-spells {
        grid-column: 5 / 7;
        grid-row: 5 / 12;
      }
      .grid-items {
        grid-column: 3 / 7;
        grid-row: 12 / 16;
      }
      .grid-level {
        grid-column: 1 / 2;
        grid-row: 2 / 3;
      }
      .grid-size {
        grid-column: 3 / 4;
        grid-row: 2 / 3;
      }
      .grid-inspiration {
        grid-column: 2 / 3;
        grid-row: 3 / 4;
      }
      .grid-health {
        grid-column: 3 / 5;
        grid-row: 4 / 5;
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
      }
      .ac-options {
        margin-top: 6px;
        display: none;
      }
      .grid-race {
        grid-column: 3 / 4;
        grid-row: 1 / 2;
      }
      .grid-alignment {
        grid-column: 4 / 5;
        grid-row: 2 / 3;
      }
      .grid-background {
        grid-column: 5 / 6;
        grid-row: 1 / 2;
      }
      .grid-proficiencies {
        grid-column: 5 / 6;
        grid-row: 2 / 4;
      }
      .grid-traits {
        grid-column: 6 / 7;
        grid-row: 2 / 4;
      }
      .grid-exp {
        grid-column: 2 / 3;
        grid-row: 2 / 3;
      }
      .grid-proficiency {
        grid-column: 2 / 3;
        grid-row: 4 / 5;
      }
      .grid-saving-throws {
        grid-column: 2 / 3;
        grid-row: 5 / 7;
      }
      .grid-skills {
        grid-column: 2 / 3;
        grid-row: 7 / 15;
        font-size: 0.6rem;
        height: auto;
        display: flex;
        flex-direction: column;
      }
      .panel {
        position: relative;
        border: 2px solid var(--line);
        border-radius: 14px;
        padding: 10px;
        background: #fff;
        width: 100%;
        height: 100%;
        overflow: visible;
      }
      .panel-label {
        position: absolute;
        top: -12px;
        left: 50%;
        transform: translateX(-50%);
        padding: 2px 8px;
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 999px;
        text-align: center;
      }
      .panel input,
      .panel textarea,
      .panel select {
        width: 100%;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        padding: 6px 8px;
        font-family: inherit;
        font-size: 0.98rem;
        background: #fff;
        height: 100%;
      }
      .panel .panel-display {
        width: 100%;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        padding: 6px 8px;
        font-family: inherit;
        font-size: 0.98rem;
        background: #f6f1e8;
        color: #4b3a2f;
        height: 100%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
      }
      .level-control {
        display: flex;
        align-items: center;
        gap: 6px;
        width: 100%;
      }
      .level-control .panel-display {
        flex: 1;
      }
      .level-adjust {
        width: 28px;
        min-width: 28px;
        height: 28px;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        background: #f6f1e8;
        color: #4b3a2f;
        font-family: inherit;
        font-size: 1rem;
        line-height: 1;
        cursor: pointer;
      }
      .text-center {
        text-align: center;
      }
      .trait-list {
        margin: 0;
        padding: 0 0 0 16px;
        height: 100%;
        overflow: auto;
      }
      .trait-list li {
        margin: 0 0 6px;
      }
      .trait-clickable {
        cursor: pointer;
      }
      .trait-clickable:hover {
        text-decoration: underline;
      }
      .tabs {
        display: grid;
        grid-template-rows: auto 1fr;
        gap: 6px;
        width: 100%;
        height: 100%;
      }
      .tab-panels {
        height: 100%;
      }
      .tab-buttons {
        display: grid;
        grid-template-columns: repeat(10, minmax(0, 1fr));
        gap: 4px;
        text-align: center;
        margin-top: 20px;
      }
      .tab-buttons label {
        display: block;
        text-align: center;
        padding: 4px 6px;
        border: 1px solid #cdbba8;
        border-radius: 6px;
        background: #fff;
        cursor: pointer;
        font-size: 0.7rem;
      }
      .tab-panel {
        display: none;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        padding: 6px;
        background: #fff;
        height: 100%;
        overflow: auto;
      }
      .grid-equipment {
        overflow: hidden;
      }
      .grid-equipment .panel-label {
        top: 8px;
      }
      .grid-equipment .actions {
        margin-top: 20px;
      }
      .grid-spells .panel-label {
        top: 8px;
      }
      .grid-spells {
        overflow: hidden;
      }
      #equipment-list {
        max-height: 100%;
        overflow: auto;
      }
      .tab-actions {
        display: flex;
        gap: 6px;
        justify-content: flex-end;
        align-items: center;
      }
      .tab-actions button {
        padding: 4px 8px;
        border-radius: 6px;
        border: 1px solid #2b1f17;
        background: #fff;
        font-family: inherit;
        font-size: 0.7rem;
        cursor: pointer;
      }
      .tab-input {
        position: absolute;
        opacity: 0;
        pointer-events: none;
      }
      #spell-tab-1:checked ~ .tab-buttons label[for="spell-tab-1"],
      #spell-tab-2:checked ~ .tab-buttons label[for="spell-tab-2"],
      #spell-tab-3:checked ~ .tab-buttons label[for="spell-tab-3"],
      #spell-tab-4:checked ~ .tab-buttons label[for="spell-tab-4"],
      #spell-tab-5:checked ~ .tab-buttons label[for="spell-tab-5"],
      #spell-tab-6:checked ~ .tab-buttons label[for="spell-tab-6"],
      #spell-tab-7:checked ~ .tab-buttons label[for="spell-tab-7"],
      #spell-tab-8:checked ~ .tab-buttons label[for="spell-tab-8"],
      #spell-tab-9:checked ~ .tab-buttons label[for="spell-tab-9"],
      #spell-tab-10:checked ~ .tab-buttons label[for="spell-tab-10"] {
        background: #f6f1e8;
        border-color: #2b1f17;
      }
      #spell-tab-1:checked ~ .tab-panels #spell-panel-1,
      #spell-tab-2:checked ~ .tab-panels #spell-panel-2,
      #spell-tab-3:checked ~ .tab-panels #spell-panel-3,
      #spell-tab-4:checked ~ .tab-panels #spell-panel-4,
      #spell-tab-5:checked ~ .tab-panels #spell-panel-5,
      #spell-tab-6:checked ~ .tab-panels #spell-panel-6,
      #spell-tab-7:checked ~ .tab-panels #spell-panel-7,
      #spell-tab-8:checked ~ .tab-panels #spell-panel-8,
      #spell-tab-9:checked ~ .tab-panels #spell-panel-9,
      #spell-tab-10:checked ~ .tab-panels #spell-panel-10 {
        display: block;
      }
      .panel input[readonly] {
        background: #f6f1e8;
        color: #4b3a2f;
      }
      textarea {
        min-height: 110px;
        resize: vertical;
      }
      .ability {
        border: 2px solid var(--line);
        border-radius: 16px;
        padding: 8px;
        background: #fff;
        text-align: center;
        width: 100%;
        height: 100%;
        margin: 0;
      }
      .ability-strength {
        grid-column: 1 / 2;
        grid-row: 3 / 5;
      }
      .ability-dexterity {
        grid-column: 1 / 2;
        grid-row: 5 / 7;
      }
      .ability-constitution {
        grid-column: 1 / 2;
        grid-row: 7 / 9;
      }
      .ability-intelligence {
        grid-column: 1 / 2;
        grid-row: 9 / 11;
      }
      .ability-wisdom {
        grid-column: 1 / 2;
        grid-row: 11 / 13;
      }
      .ability-charisma {
        grid-column: 1 / 2;
        grid-row: 13 / 15;
      }
      .ability h3 {
        margin: 0 0 8px;
        font-size: 0.85rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }
      .ability .ability-row {
        display: grid;
        grid-template-rows: auto auto;
        gap: 6px;
        justify-items: center;
      }
      .ability input,
      .ability .ability-score-display {
        text-align: center;
        font-size: 1.05rem;
      }
      .ability input[type="number"] {
        width: 64px;
      }
      .ability .ability-score-display {
        width: 64px;
        min-height: 32px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        background: #f6f1e8;
        color: #4b3a2f;
      }
      .ability .ability-mod-display {
        width: 40px;
        min-height: 32px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        background: #f6f1e8;
        color: #4b3a2f;
      }
      .ability input[readonly] {
        width: 40px;
      }
      .rollable {
        cursor: pointer;
      }
      .rollable:hover {
        text-decoration: underline;
      }
      .list {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .grid-saving-throws .list {
        gap: 0.5px;
        margin-top: 20px;
      }
      .grid-saving-throws input[type="checkbox"] {
        pointer-events: none;
      }
      .grid-skills .list {
        gap: 3px;
      }
      .list-item {
        display: grid;
        grid-template-columns: 18px 1fr 58px;
        align-items: center;
        gap: 6px;
        position: relative;
      }
      .list-value {
        display: inline-block;
        width: 58px;
        text-align: center;
        padding: 2px 4px;
        font-variant-numeric: tabular-nums;
      }
      .list-item.rollable-row {
        cursor: pointer;
      }
      .list-item.rollable-row span,
      .list-item.rollable-row input[type="text"],
      .list-item.rollable-row input[readonly] {
        cursor: pointer;
      }
      .list-item input[type="number"],
      .list-item input[type="text"] {
        width: 58px;
        text-align: center;
        padding: 4px 4px;
      }
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }
      .small-input {
        text-align: center;
      }
      .section-stack {
        display: grid;
        gap: 12px;
      }
      }
      .dice-panel {
        position: fixed;
        left: 16px;
        bottom: 16px;
        width: min(320px, 90vw);
        z-index: 999;
        background: #fff;
        border: 2px solid var(--line);
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 12px 24px rgba(43, 31, 23, 0.15);
      }
      .sticky-roll {
        position: fixed;
        left: 16px;
        bottom: 16px;
        z-index: 1000;
        padding: 10px 14px;
        border: 2px solid var(--line);
        border-radius: 12px;
        background: #fff;
        font-size: 0.95rem;
        box-shadow: 0 10px 20px rgba(43, 31, 23, 0.15);
      }
      .sticky-roll-title {
        margin: 0 0 8px;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--muted);
      }
      .dice-title {
        margin: 0 0 12px;
        font-size: 0.95rem;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--muted);
      }
      #roll-btn {
        padding: 10px 18px;
        font-size: 1rem;
        font-family: inherit;
        border-radius: 12px;
        border: 2px solid var(--line);
        background: var(--accent);
        color: #fff;
        cursor: pointer;
      }
      #roll-result {
        margin-top: 10px;
        font-size: 1rem;
        display: grid;
        gap: 6px;
      }
      .roll-line {
        display: flex;
        justify-content: space-between;
        gap: 8px;
      }
      .roll-total {
        margin-top: 6px;
        padding-top: 6px;
        border-top: 1px solid #cdbba8;
        font-weight: 700;
        text-align: right;
      }
      .actions {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
      }
      .actions select,
      .actions button {
        padding: 6px 10px;
        border-radius: 10px;
        border: 2px solid var(--line);
        font-family: inherit;
        background: #fff;
      }
      .actions .active-weapon {
        font-size: 0.9rem;
        color: var(--muted);
      }
      .actions .equip-status {
        font-size: 0.85rem;
        color: var(--accent);
      }
      #add-weapon {
        background: var(--accent);
        color: #fff;
        cursor: pointer;
      }
      #attack-roll {
        background: #2f3a4a;
        color: #fff;
        cursor: pointer;
      }
      .hit-option {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 0.9rem;
        color: var(--muted);
      }
      #equipment-list {
        display: grid;
        gap: 6px;
      }
      .equipment-item {
        display: grid;
        grid-template-columns: auto 1fr auto;
        align-items: center;
        gap: 8px;
        padding: 6px 8px;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        background: #fff;
      }
      .equipment-item.active {
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(184, 74, 45, 0.15);
      }
      .equip-btn {
        padding: 4px 8px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #c23a2b;
        color: #fff;
        cursor: pointer;
        font-size: 0.85rem;
      }
      .equip-btn.equipped {
        background: #2b63c2;
      }
      .equip-badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background: #f6f1e8;
        font-size: 0.75rem;
        color: var(--muted);
      }
      .twohand-btn {
        padding: 4px 8px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #f1efe7;
        color: var(--fg);
        cursor: pointer;
        font-size: 0.8rem;
      }
      .twohand-btn.active {
        background: #2b63c2;
        color: #fff;
      }
      .twohand-btn[disabled] {
        cursor: not-allowed;
        opacity: 0.6;
      }
      .equipment-dmg {
        padding: 4px 8px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #f6f1e8;
        cursor: pointer;
      }
      .equipment-remove {
        width: 26px;
        height: 26px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        color: #a02a20;
        font-weight: 700;
        line-height: 1;
        cursor: pointer;
      }
      .item-panel {
        position: fixed;
        right: 16px;
        top: 16px;
        width: min(360px, 92vw);
        max-height: calc(100vh - 32px);
        overflow: auto;
        z-index: 1001;
        background: #fff;
        border: 2px solid var(--line);
        border-radius: 16px;
        padding: 16px 16px 18px;
        box-shadow: 0 16px 30px rgba(43, 31, 23, 0.2);
        display: none;
      }
      .item-panel.open {
        display: block;
      }
      .item-panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 10px;
      }
      .item-panel-title {
        margin: 0;
        font-size: 1.1rem;
      }
      .item-panel-close {
        border: 2px solid var(--line);
        background: #fff;
        width: 32px;
        height: 32px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 1rem;
        line-height: 1;
      }
      .item-panel-close:hover {
        background: #f6f1e8;
      }
      .item-panel-body {
        display: grid;
        gap: 8px;
        color: var(--fg);
      }
      .item-row {
        display: grid;
        grid-template-columns: 120px 1fr;
        gap: 8px;
        align-items: baseline;
        font-size: 0.95rem;
      }
      .item-row strong {
        font-weight: 700;
        color: var(--muted);
      }
      .item-tooltip {
        position: relative;
        cursor: help;
      }
      .item-tooltip::after {
        content: attr(data-tooltip);
        position: absolute;
        left: 0;
        top: 100%;
        margin-top: 6px;
        min-width: 160px;
        max-width: 280px;
        padding: 8px 10px;
        border-radius: 10px;
        background: #1f1711;
        color: #fff7ee;
        font-size: 0.82rem;
        line-height: 1.25;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        opacity: 0;
        pointer-events: none;
        transform: translateY(-4px);
        transition: opacity 0.15s ease, transform 0.15s ease;
        z-index: 5;
        white-space: normal;
      }
      .item-tooltip:hover::after {
        opacity: 1;
        transform: translateY(0);
      }
      .weapon-picker {
        position: fixed;
        left: 16px;
        top: 16px;
        width: min(360px, 92vw);
        max-height: calc(100vh - 32px);
        overflow: auto;
        z-index: 1002;
        background: #fff;
        border: 2px solid var(--line);
        border-radius: 16px;
        padding: 14px;
        box-shadow: 0 16px 30px rgba(43, 31, 23, 0.2);
        display: none;
      }
      .weapon-picker.open {
        display: block;
      }
      .ability-picker .weapon-picker-header {
        grid-template-columns: 1fr auto;
      }
      .ability-picker .picker-title {
        font-weight: 700;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        font-size: 0.78rem;
        color: var(--muted);
      }
      .ability-picker .ability-values,
      .ability-picker .ability-choices {
        display: grid;
        gap: 8px;
        margin-bottom: 12px;
      }
      .ability-picker .ability-options {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 8px;
        margin-bottom: 12px;
      }
      .ability-picker .ability-values {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
      .ability-picker .ability-choices {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .ability-picker button {
        padding: 8px 10px;
        border-radius: 10px;
        border: 2px solid var(--line);
        background: #fff;
        font-family: inherit;
        cursor: pointer;
      }
      .ability-picker button.selected {
        border-color: var(--accent);
        background: #fff4ec;
      }
      .ability-picker button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .background-config-picker .weapon-picker-header {
        grid-template-columns: 1fr auto auto;
      }
      .background-config-body {
        display: grid;
        gap: 12px;
      }
      .background-config-section {
        border: 1px solid #d8c7b5;
        border-radius: 10px;
        padding: 10px;
        background: #fffaf5;
      }
      .background-config-section h4 {
        margin: 0 0 8px;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: var(--muted);
      }
      .background-choice-row {
        display: grid;
        gap: 8px;
        margin-bottom: 8px;
      }
      .background-choice-row label {
        font-size: 0.82rem;
      }
      .background-choice-row select {
        width: 100%;
        padding: 6px 8px;
        border-radius: 8px;
        border: 2px solid var(--line);
        font-family: inherit;
        background: #fff;
      }
      .background-mode-options {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
        margin-bottom: 10px;
      }
      .background-mode-options button {
        padding: 8px 10px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #fff;
        font-family: inherit;
        cursor: pointer;
      }
      .background-mode-options button.selected {
        border-color: var(--accent);
        background: #fff4ec;
      }
      .background-static-list {
        margin: 0;
        padding-left: 18px;
        font-size: 0.85rem;
      }
      .background-static-list li {
        margin-bottom: 4px;
      }
      .class-equipment-picker .weapon-picker-header {
        grid-template-columns: 1fr auto auto;
      }
      .class-equipment-body {
        display: grid;
        gap: 12px;
      }
      .class-equipment-row {
        border: 1px solid #d8c7b5;
        border-radius: 10px;
        padding: 10px;
        background: #fffaf5;
        display: grid;
        gap: 8px;
      }
      .class-equipment-row h4 {
        margin: 0;
        font-size: 0.8rem;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      .class-equipment-row select {
        width: 100%;
        padding: 6px 8px;
        border-radius: 8px;
        border: 2px solid var(--line);
        font-family: inherit;
        background: #fff;
      }
      .weapon-picker-header {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 8px;
        align-items: center;
        margin-bottom: 12px;
      }
      .weapon-picker .weapon-picker-header {
        position: sticky;
        top: 0;
        z-index: 2;
        background: #fff;
        padding-bottom: 8px;
      }
      .size-picker .weapon-picker-header {
        grid-template-columns: 1fr auto;
      }
      .size-picker .picker-title {
        font-weight: 700;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        font-size: 0.78rem;
        color: var(--muted);
      }
      .alignment-picker .weapon-picker-header {
        grid-template-columns: 1fr auto;
      }
      .weapon-picker-header input {
        width: 100%;
        border: 1px solid #cdbba8;
        border-radius: 10px;
        padding: 6px 10px;
        font-family: inherit;
      }
      .weapon-picker-add,
      .weapon-picker-close {
        border-radius: 10px;
        border: 2px solid var(--line);
        padding: 6px 12px;
        font-family: inherit;
        cursor: pointer;
      }
      .weapon-picker-add {
        background: var(--accent);
        color: #fff;
      }
      .weapon-picker-close {
        background: #fff;
      }
      .weapon-category {
        margin: 10px 0 6px;
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
      }
      .weapon-list {
        display: grid;
        gap: 6px;
      }
      .weapon-option {
        border: 1px solid #cdbba8;
        border-radius: 10px;
        padding: 8px 10px;
        cursor: pointer;
        background: #fff;
      }
      .weapon-option strong {
        display: block;
        font-size: 0.95rem;
      }
      .weapon-option span {
        font-size: 0.82rem;
        color: var(--muted);
      }
      .weapon-option.selected {
        border-color: var(--accent);
        background: #fff4ec;
      }
      .spell-list {
        display: grid;
        gap: 6px;
      }
      .spell-item {
        display: grid;
        grid-template-columns: 1fr auto;
        align-items: center;
        gap: 8px;
        padding: 6px 8px;
        border: 1px solid #cdbba8;
        border-radius: 8px;
        background: #fff;
      }
      .spell-item strong {
        display: block;
        font-size: 0.95rem;
      }
      .spell-meta {
        font-size: 0.8rem;
        color: var(--muted);
      }
      .spell-remove {
        padding: 4px 8px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #c23a2b;
        color: #fff;
        cursor: pointer;
        font-size: 0.75rem;
      }
      .grid-items {
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-height: 0;
      }
      #add-item {
        background: var(--accent);
        color: #fff;
        cursor: pointer;
      }
      #items-list {
        display: grid;
        gap: 6px;
        max-height: 100%;
        overflow: auto;
      }
      .inventory-header,
      .inventory-row {
        display: grid;
        grid-template-columns: 140px minmax(0, 1fr) 80px auto;
        gap: 8px;
        align-items: start;
      }
      .inventory-header.with-qty,
      .inventory-row.with-qty {
        grid-template-columns: 120px minmax(0, 1fr) 80px 52px auto;
      }
      .inventory-header {
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--muted);
        padding: 0 4px;
        position: sticky;
        top: 0;
        z-index: 1;
        background: #f6f1e8;
        border-radius: 6px;
      }
      .inventory-row {
        border: 1px solid #cdbba8;
        border-radius: 8px;
        padding: 6px 8px;
        background: #fff;
        font-size: 0.9rem;
      }
      .inventory-name {
        font-weight: 700;
        cursor: pointer;
      }
      .inventory-desc {
        color: var(--muted);
        white-space: normal;
        overflow-wrap: anywhere;
      }
      .inventory-gold,
      .inventory-qty {
        text-align: center;
      }
      .inventory-remove {
        padding: 4px 8px;
        border-radius: 8px;
        border: 2px solid var(--line);
        background: #c23a2b;
        color: #fff;
        cursor: pointer;
        font-size: 0.75rem;
      }
      @media (max-width: 960px) {
        .layout {
          grid-template-columns: 1fr;
        }
        .header-grid {
          grid-template-columns: 1fr;
        }
        .stats-grid {
          grid-template-columns: 1fr;
        }
        .dice-panel {
          left: 12px;
          bottom: 12px;
          width: min(360px, 94vw);
        }
        .item-panel {
          right: 12px;
          top: 12px;
        }
        .weapon-picker {
          left: 12px;
          top: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <div class="title">Interactive DnD Sheet</div>
      <div class="layout">
        <section class="sheet" aria-label="Character Sheet">
          <div class="header-grid">
            <div class="grid-debug">
              <span>1</span>
              <span>2</span>
              <span>3</span>
              <span>4</span>
              <span>5</span>
              <span>6</span>
              <span>7</span>
              <span>8</span>
              <span>9</span>
              <span>10</span>
              <span>11</span>
              <span>12</span>
              <span>13</span>
              <span>14</span>
              <span>15</span>
              <span>16</span>
              <span>17</span>
              <span>18</span>
              <span>19</span>
              <span>20</span>
              <span>21</span>
              <span>22</span>
              <span>23</span>
              <span>24</span>
              <span>25</span>
              <span>26</span>
              <span>27</span>
              <span>28</span>
              <span>29</span>
              <span>30</span>
              <span>31</span>
              <span>32</span>
              <span>33</span>
              <span>34</span>
              <span>35</span>
              <span>36</span>
              <span>37</span>
              <span>38</span>
              <span>39</span>
              <span>40</span>
              <span>41</span>
              <span>42</span>
              <span>43</span>
              <span>44</span>
              <span>45</span>
              <span>46</span>
              <span>47</span>
              <span>48</span>
              <span>49</span>
              <span>50</span>
              <span>51</span>
              <span>52</span>
              <span>53</span>
              <span>54</span>
              <span>55</span>
              <span>56</span>
              <span>57</span>
              <span>58</span>
              <span>59</span>
              <span>60</span>
              <span>61</span>
              <span>62</span>
              <span>63</span>
              <span>64</span>
              <span>65</span>
              <span>66</span>
              <span>67</span>
              <span>68</span>
              <span>69</span>
              <span>70</span>
              <span>71</span>
              <span>72</span>
              <span>73</span>
              <span>74</span>
              <span>75</span>
              <span>76</span>
              <span>77</span>
              <span>78</span>
              <span>79</span>
              <span>80</span>
              <span>81</span>
              <span>82</span>
              <span>83</span>
              <span>84</span>
              <span>85</span>
              <span>86</span>
              <span>87</span>
              <span>88</span>
              <span>89</span>
              <span>90</span>
              <span>91</span>
              <span>92</span>
              <span>93</span>
              <span>94</span>
              <span>95</span>
              <span>96</span>
              <span>97</span>
              <span>98</span>
              <span>99</span>
              <span>100</span>
              <span>101</span>
              <span>102</span>
              <span>103</span>
              <span>104</span>
              <span>105</span>
              <span>106</span>
              <span>107</span>
              <span>108</span>
              <span>109</span>
              <span>110</span>
              <span>111</span>
              <span>112</span>
              <span>113</span>
              <span>114</span>
              <span>115</span>
              <span>116</span>
              <span>117</span>
              <span>118</span>
              <span>119</span>
              <span>120</span>
              <span>121</span>
              <span>122</span>
              <span>123</span>
              <span>124</span>
              <span>125</span>
              <span>126</span>
              <span>127</span>
              <span>128</span>
              <span>129</span>
              <span>130</span>
              <span>131</span>
              <span>132</span>
              <span>133</span>
              <span>134</span>
              <span>135</span>
              <span>136</span>
              <span>137</span>
              <span>138</span>
              <span>139</span>
              <span>140</span>
              <span>141</span>
              <span>142</span>
              <span>143</span>
              <span>144</span>
              <span>145</span>
              <span>146</span>
              <span>147</span>
              <span>148</span>
              <span>149</span>
              <span>150</span>
              <span>151</span>
              <span>152</span>
              <span>153</span>
              <span>154</span>
              <span>155</span>
              <span>156</span>
              <span>157</span>
              <span>158</span>
              <span>159</span>
              <span>160</span>
              <span>161</span>
              <span>162</span>
              <span>163</span>
              <span>164</span>
              <span>165</span>
              <span>166</span>
              <span>167</span>
              <span>168</span>
              <span>169</span>
              <span>170</span>
              <span>171</span>
              <span>172</span>
              <span>173</span>
              <span>174</span>
              <span>175</span>
              <span>176</span>
              <span>177</span>
              <span>178</span>
              <span>179</span>
              <span>180</span>
              <span>181</span>
              <span>182</span>
              <span>183</span>
              <span>184</span>
              <span>185</span>
              <span>186</span>
              <span>187</span>
              <span>188</span>
              <span>189</span>
              <span>190</span>
              <span>191</span>
              <span>192</span>
              <span>193</span>
              <span>194</span>
              <span>195</span>
              <span>196</span>
              <span>197</span>
              <span>198</span>
              <span>199</span>
              <span>200</span>
              <span>201</span>
              <span>202</span>
              <span>203</span>
              <span>204</span>
              <span>205</span>
              <span>206</span>
              <span>207</span>
              <span>208</span>
              <span>209</span>
              <span>210</span>
              <span>211</span>
              <span>212</span>
              <span>213</span>
              <span>214</span>
              <span>215</span>
              <span>216</span>
              <span>217</span>
              <span>218</span>
              <span>219</span>
              <span>220</span>
              <span>221</span>
              <span>222</span>
              <span>223</span>
              <span>224</span>
              <span>225</span>
              <span>226</span>
              <span>227</span>
              <span>228</span>
              <span>229</span>
              <span>230</span>
              <span>231</span>
              <span>232</span>
              <span>233</span>
              <span>234</span>
              <span>235</span>
              <span>236</span>
              <span>237</span>
              <span>238</span>
              <span>239</span>
              <span>240</span>
            </div>

            <div class="panel grid-character-name">
              <div class="panel-label">Character Name</div>
              <input id="character-name" type="text" class="text-center" />
            </div>
            <div class="panel grid-class">
              <div class="panel-label">Class</div>
              <input id="class-level" type="text" />
            </div>
            <div class="panel grid-armor-class">
              <div class="panel-label">Armor Class</div>
              <span id="armor-class" class="panel-display text-center"></span>
            </div>
            <div class="panel grid-initiative">
              <div class="panel-label">Initiative</div>
              <span id="initiative" class="panel-display text-center rollable" role="button" tabindex="0"></span>
            </div>
            <div class="panel grid-speed">
              <div class="panel-label">Speed</div>
              <span id="speed" class="panel-display text-center"></span>
            </div>
            <div class="panel grid-passive-wisdom">
              <div class="panel-label">PASSIVE WISDOM (PERCEPTION)</div>
              <span id="passive-wisdom-perception" class="panel-display text-center"></span>
            </div>
            <div class="panel grid-level">
              <div class="panel-label">Level</div>
              <div class="level-control">
                <button id="level-decrease" class="level-adjust" type="button" aria-label="Decrease level">-</button>
                <span id="level" class="panel-display text-center"></span>
                <button id="level-increase" class="level-adjust" type="button" aria-label="Increase level">+</button>
              </div>
            </div>
            <div class="panel grid-size">
              <div class="panel-label">Size</div>
              <input id="size" type="text" readonly inputmode="none" />
            </div>
            <div class="panel grid-inspiration">
              <div class="panel-label">Inspiration</div>
              <input id="inspiration" type="text" />
            </div>
            <div class="panel grid-health">
              <div class="panel-label">Health</div>
              <div class="panel">
                <input id="current-hp" type="number" min="0" />
              </div>
              <div class="panel">
                <span id="total-hp" class="panel-display text-center"></span>
              </div>
            </div>
            <div class="panel grid-race">
              <div class="panel-label">Race</div>
              <input id="race" type="text" />
            </div>
            <div class="panel grid-alignment">
              <div class="panel-label">Alignment</div>
              <input id="alignment" type="text" readonly disabled />
            </div>
            <div class="panel grid-background">
              <div class="panel-label">Background</div>
              <input id="background" type="text" />
            </div>
            <div class="panel grid-proficiencies">
              <div class="panel-label">Proficiencies</div>
              <ul id="proficiencies" class="trait-list" aria-live="polite"></ul>
            </div>
            <div class="panel grid-traits">
              <div class="panel-label">Feats</div>
              <ul id="traits" class="trait-list" aria-live="polite"></ul>
            </div>
            <div class="panel grid-exp">
              <div class="panel-label">EXP</div>
              <span id="xp" class="panel-display text-center"></span>
            </div>
            <div class="panel grid-proficiency">
              <div class="panel-label">Proficiency Bonus</div>
              <input id="proficiency-bonus" type="text" readonly class="text-center" />
            </div>
            <div class="panel grid-saving-throws">
              <div class="panel-label">Saving Throws</div>
              <div class="list">
                <div class="list-item" data-ability="str"><input id="save-str-prof" type="checkbox" /><span>Strength</span><span class="save-value list-value">+0</span></div>
                <div class="list-item" data-ability="dex"><input id="save-dex-prof" type="checkbox" /><span>Dexterity</span><span class="save-value list-value">+0</span></div>
                <div class="list-item" data-ability="con"><input id="save-con-prof" type="checkbox" /><span>Constitution</span><span class="save-value list-value">+0</span></div>
                <div class="list-item" data-ability="int"><input id="save-int-prof" type="checkbox" /><span>Intelligence</span><span class="save-value list-value">+0</span></div>
                <div class="list-item" data-ability="wis"><input id="save-wis-prof" type="checkbox" /><span>Wisdom</span><span class="save-value list-value">+0</span></div>
                <div class="list-item" data-ability="cha"><input id="save-cha-prof" type="checkbox" /><span>Charisma</span><span class="save-value list-value">+0</span></div>
              </div>
            </div>
            <div class="ability ability-strength" data-ability="str">
              <h3>Strength</h3>
              <div class="ability-row">
                <span id="str-score" class="ability-score-display"></span>
                <span id="str-mod" class="ability-mod-display"></span>
              </div>
            </div>
            <div class="ability ability-dexterity" data-ability="dex">
              <h3>Dexterity</h3>
              <div class="ability-row">
                <span id="dex-score" class="ability-score-display"></span>
                <span id="dex-mod" class="ability-mod-display"></span>
              </div>
            </div>
            <div class="ability ability-constitution" data-ability="con">
              <h3>Constitution</h3>
              <div class="ability-row">
                <span id="con-score" class="ability-score-display"></span>
                <span id="con-mod" class="ability-mod-display"></span>
              </div>
            </div>
            <div class="ability ability-intelligence" data-ability="int">
              <h3>Intelligence</h3>
              <div class="ability-row">
                <span id="int-score" class="ability-score-display"></span>
                <span id="int-mod" class="ability-mod-display"></span>
              </div>
            </div>
            <div class="ability ability-wisdom" data-ability="wis">
              <h3>Wisdom</h3>
              <div class="ability-row">
                <span id="wis-score" class="ability-score-display"></span>
                <span id="wis-mod" class="ability-mod-display"></span>
              </div>
            </div>
            <div class="ability ability-charisma" data-ability="cha">
              <h3>Charisma</h3>
              <div class="ability-row">
                <span id="cha-score" class="ability-score-display"></span>
                <span id="cha-mod" class="ability-mod-display"></span>
              </div>
            </div>
          
            <div class="panel grid-skills">
              <div class="panel-label">Skills</div>
              <div class="list">
                  <div class="list-item" data-ability="dex"><input id="skill-acrobatics-prof" type="checkbox" /><span>Acrobatics (Dex)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="wis"><input id="skill-animal-handling-prof" type="checkbox" /><span>Animal Handling (Wis)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="int"><input id="skill-arcana-prof" type="checkbox" /><span>Arcana (Int)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="str"><input id="skill-athletics-prof" type="checkbox" /><span>Athletics (Str)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="cha"><input id="skill-deception-prof" type="checkbox" /><span>Deception (Cha)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="int"><input id="skill-history-prof" type="checkbox" /><span>History (Int)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="wis"><input id="skill-insight-prof" type="checkbox" /><span>Insight (Wis)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="cha"><input id="skill-intimidation-prof" type="checkbox" /><span>Intimidation (Cha)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="int"><input id="skill-investigation-prof" type="checkbox" /><span>Investigation (Int)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="wis"><input id="skill-medicine-prof" type="checkbox" /><span>Medicine (Wis)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="int"><input id="skill-nature-prof" type="checkbox" /><span>Nature (Int)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="wis"><input id="skill-perception-prof" type="checkbox" /><span>Perception (Wis)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="cha"><input id="skill-performance-prof" type="checkbox" /><span>Performance (Cha)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="cha"><input id="skill-persuasion-prof" type="checkbox" /><span>Persuasion (Cha)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="int"><input id="skill-religion-prof" type="checkbox" /><span>Religion (Int)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="dex"><input id="skill-sleight-of-hand-prof" type="checkbox" /><span>Sleight of Hand (Dex)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="dex"><input id="skill-stealth-prof" type="checkbox" /><span>Stealth (Dex)</span><span class="skill-value list-value">+0</span></div>
                  <div class="list-item" data-ability="wis"><input id="skill-survival-prof" type="checkbox" /><span>Survival (Wis)</span><span class="skill-value list-value">+0</span></div>
              </div>
            </div>



              <div class="panel grid-equipment">
              <div class="panel-label">Equipment</div>
              <div class="actions" style="margin-bottom: 8px;">
                <button id="add-weapon" type="button">Add Weapon/Armor</button>
                <button id="attack-roll" type="button">Hit</button>
                <span class="active-weapon" id="active-weapon-label">No weapon selected</span>
                <span class="equip-status" id="equip-status"></span>
              </div>
              <div id="equipment-list"></div>
            </div>
            <div class="panel grid-spells">
              <div class="panel-label">Spells</div>
              <div class="tabs">
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-1" checked />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-2" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-3" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-4" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-5" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-6" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-7" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-8" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-9" />
                <input class="tab-input" type="radio" name="spells-tab" id="spell-tab-10" />
                <div class="tab-buttons">
                  <label for="spell-tab-1">C</label>
                  <label for="spell-tab-2">1</label>
                  <label for="spell-tab-3">2</label>
                  <label for="spell-tab-4">3</label>
                  <label for="spell-tab-5">4</label>
                  <label for="spell-tab-6">5</label>
                  <label for="spell-tab-7">6</label>
                  <label for="spell-tab-8">7</label>
                  <label for="spell-tab-9">8</label>
                  <label for="spell-tab-10">9</label>
                </div>
                <div class="tab-panels">
                  <div class="tab-panel" id="spell-panel-1"></div>
                  <div class="tab-panel" id="spell-panel-2"></div>
                  <div class="tab-panel" id="spell-panel-3"></div>
                  <div class="tab-panel" id="spell-panel-4"></div>
                  <div class="tab-panel" id="spell-panel-5"></div>
                  <div class="tab-panel" id="spell-panel-6"></div>
                  <div class="tab-panel" id="spell-panel-7"></div>
                  <div class="tab-panel" id="spell-panel-8"></div>
                  <div class="tab-panel" id="spell-panel-9"></div>
                  <div class="tab-panel" id="spell-panel-10"></div>
                </div>
                <div class="tab-actions">
                  <button id="add-spell" type="button">Add Spell</button>
                  <button id="remove-spell" type="button">Remove Spell</button>
                </div>
              </div>
            </div>
            <div class="panel grid-items">
              <div class="panel-label">Items</div>
              <div class="actions" style="margin-bottom: 8px;">
                <button id="add-item" type="button">Add Item</button>
              </div>
              <div id="items-list"></div>
            </div>
            </div>

          
        </section>
      </div>
    </div>
    <aside class="sticky-roll" aria-live="polite">
      <div class="sticky-roll-title">Dice Roll</div>
      <div id="roll-result">No rolls yet.</div>
    </aside>
    <audio id="dice-sound" src="diceroll.mp3" preload="auto"></audio>
    <aside class="item-panel" id="item-panel" aria-live="polite" aria-label="Item details">
      <div class="item-panel-header">
        <h2 class="item-panel-title" id="item-panel-title">Item</h2>
        <button class="item-panel-close" id="item-panel-close" type="button" aria-label="Close item details"></button>
      </div>
      <div class="item-panel-body" id="item-panel-body"></div>
    </aside>
    <aside class="weapon-picker" id="weapon-picker" aria-live="polite" aria-label="Weapon picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <input id="weapon-search" type="search" placeholder="Search weapons..." />
        <button id="weapon-picker-add" class="weapon-picker-add" type="button" disabled>Add</button>
        <button id="weapon-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="weapon-picker-list"></div>
    </aside>
    <aside class="weapon-picker race-picker" id="race-picker" aria-live="polite" aria-label="Race picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <input id="race-search" type="search" placeholder="Search races..." />
        <button id="race-picker-add" class="weapon-picker-add" type="button" disabled>Add</button>
        <button id="race-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="race-picker-list"></div>
    </aside>
    <aside class="weapon-picker size-picker" id="size-picker" aria-live="polite" aria-label="Size picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <div class="picker-title">Choose size</div>
        <button id="size-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="size-picker-list"></div>
    </aside>
    <aside class="weapon-picker alignment-picker" id="alignment-picker" aria-live="polite" aria-label="Alignment picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <div class="picker-title">Choose alignment</div>
        <button id="alignment-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="alignment-picker-list"></div>
    </aside>
    <aside class="weapon-picker ability-picker" id="ability-picker" aria-live="polite" aria-label="Ability score picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <div class="picker-title">Choose ability scores</div>
        <button id="ability-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div class="ability-options" id="ability-options"></div>
      <div class="ability-values" id="ability-values"></div>
      <div class="ability-choices" id="ability-choices"></div>
    </aside>
    <aside class="weapon-picker spell-picker" id="spell-picker" aria-live="polite" aria-label="Spell picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <input id="spell-search" type="search" placeholder="Search cantrips..." />
        <button id="spell-picker-add" class="weapon-picker-add" type="button" disabled>Add</button>
        <button id="spell-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="spell-picker-list"></div>
    </aside>
    <aside class="weapon-picker class-picker" id="class-picker" aria-live="polite" aria-label="Class picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <input id="class-search" type="search" placeholder="Search classes..." />
        <button id="class-picker-add" class="weapon-picker-add" type="button" disabled>Add</button>
        <button id="class-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="class-picker-list"></div>
    </aside>
    <aside class="weapon-picker class-equipment-picker" id="class-equipment-picker" aria-live="polite" aria-label="Class starting equipment" aria-hidden="true">
      <div class="weapon-picker-header">
        <div class="picker-title">Class starting equipment</div>
        <button id="class-equipment-apply" class="weapon-picker-add" type="button">Apply</button>
        <button id="class-equipment-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div class="class-equipment-body" id="class-equipment-body"></div>
    </aside>
    <aside class="weapon-picker background-picker" id="background-picker" aria-live="polite" aria-label="Background picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <input id="background-search" type="search" placeholder="Search backgrounds..." />
        <button id="background-picker-add" class="weapon-picker-add" type="button" disabled>Add</button>
        <button id="background-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="background-picker-list"></div>
    </aside>
    <aside class="weapon-picker background-config-picker" id="background-config-picker" aria-live="polite" aria-label="Background choices" aria-hidden="true">
      <div class="weapon-picker-header">
        <div class="picker-title">Background choices</div>
        <button id="background-config-apply" class="weapon-picker-add" type="button">Apply</button>
        <button id="background-config-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div class="background-config-body" id="background-config-body"></div>
    </aside>
    <aside class="weapon-picker item-picker" id="item-picker" aria-live="polite" aria-label="Item picker" aria-hidden="true">
      <div class="weapon-picker-header">
        <input id="item-search" type="search" placeholder="Search items..." />
        <button id="item-picker-add" class="weapon-picker-add" type="button" disabled>Add</button>
        <button id="item-picker-close" class="weapon-picker-close" type="button">X</button>
      </div>
      <div id="item-picker-list"></div>
    </aside>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";
      import {
        getFirestore,
        doc,
        setDoc,
        onSnapshot,
        serverTimestamp,
        collection,
        getDocs,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

      const firebaseConfig = {
        apiKey: "AIzaSyAA4Ak_mKs67_b2LIxjSQ0TabAIa5JE4rA",
        authDomain: "dnd-dice-ca4b0.firebaseapp.com",
        projectId: "dnd-dice-ca4b0",
        storageBucket: "dnd-dice-ca4b0.firebasestorage.app",
        messagingSenderId: "338841368755",
        appId: "1:338841368755:web:80065ec73a88b9e2ba58c6",
        measurementId: "G-VPGSM8BFR6",
      };

      const app = initializeApp(firebaseConfig);
      getAnalytics(app);
      const db = getFirestore(app);

      function createClientId() {
        if (window.crypto?.randomUUID) return window.crypto.randomUUID();
        return `client_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
      }

      function getOrCreateClientId() {
        const storageKey = "dnd_client_id_v1";
        try {
          const existing = localStorage.getItem(storageKey);
          if (existing) return existing;
          const next = createClientId();
          localStorage.setItem(storageKey, next);
          return next;
        } catch (error) {
          return createClientId();
        }
      }

      const clientId = getOrCreateClientId();
      const rollRef = doc(db, "dice", `d20_${clientId}`);
      const sheetRef = doc(db, "sheets", clientId);
      const resultEl = document.getElementById("roll-result");
      const diceSoundEl = document.getElementById("dice-sound");
      const rollBtn = document.getElementById("roll-btn");
      const classInput = document.getElementById("class-level");
      const raceInput = document.getElementById("race");
      const backgroundInput = document.getElementById("background");
      const alignmentInput = document.getElementById("alignment");
      const speedInput = document.getElementById("speed");
      const sizeInput = document.getElementById("size");
      const armorClassEl = document.getElementById("armor-class");
      const initiativeEl = document.getElementById("initiative");
      const levelInput = document.getElementById("level");
      const levelDecreaseBtn = document.getElementById("level-decrease");
      const levelIncreaseBtn = document.getElementById("level-increase");
      const xpInput = document.getElementById("xp");
      const totalHpInput = document.getElementById("total-hp");
      const currentHpInput = document.getElementById("current-hp");
      const proficienciesListEl = document.getElementById("proficiencies");
      const abilityPicker = document.getElementById("ability-picker");
      const abilityPickerClose = document.getElementById("ability-picker-close");
      const abilityOptionsEl = document.getElementById("ability-options");
      const abilityValuesEl = document.getElementById("ability-values");
      const abilityChoicesEl = document.getElementById("ability-choices");
      const traitsListEl = document.getElementById("traits");
      const fieldEls = Array.from(
        document.querySelectorAll(
          "input[id]:not([data-nosave]), textarea[id]:not([data-nosave]), select[id]:not([data-nosave])"
        )
      );
      const abilityScores = {
        str: document.getElementById("str-score"),
        dex: document.getElementById("dex-score"),
        con: document.getElementById("con-score"),
        int: document.getElementById("int-score"),
        wis: document.getElementById("wis-score"),
        cha: document.getElementById("cha-score"),
      };
      const abilityMods = {
        str: document.getElementById("str-mod"),
        dex: document.getElementById("dex-mod"),
        con: document.getElementById("con-mod"),
        int: document.getElementById("int-mod"),
        wis: document.getElementById("wis-mod"),
        cha: document.getElementById("cha-mod"),
      };
      const proficiencyBonusEl = document.getElementById("proficiency-bonus");
      const levelEl = document.getElementById("level");
      const passivePerceptionEl = document.getElementById("passive-wisdom-perception");
      const computedDisplayEls = [levelEl, xpInput, passivePerceptionEl, speedInput, totalHpInput, armorClassEl, initiativeEl];
      const saveRows = Array.from(document.querySelectorAll(".list-item[data-ability]"))
        .filter((row) => row.querySelector(".save-value"));
      const skillRows = Array.from(document.querySelectorAll(".list-item[data-ability]"))
        .filter((row) => row.querySelector(".skill-value"));
      skillRows.forEach((row) => {
        const checkbox = row.querySelector("input[type='checkbox']");
        if (checkbox) {
          checkbox.disabled = true;
        }
      });
      const attackRollBtn = document.getElementById("attack-roll");
      const attackProfEl = document.getElementById("attack-prof");
      const addWeaponBtn = document.getElementById("add-weapon");
      const addSpellBtn = document.getElementById("add-spell");
      const removeSpellBtn = document.getElementById("remove-spell");
      const addItemBtn = document.getElementById("add-item");
      const activeWeaponLabel = document.getElementById("active-weapon-label");
      const equipStatusEl = document.getElementById("equip-status");
      const weaponPicker = document.getElementById("weapon-picker");
      const weaponPickerList = document.getElementById("weapon-picker-list");
      const weaponSearch = document.getElementById("weapon-search");
      const weaponPickerAdd = document.getElementById("weapon-picker-add");
      const weaponPickerClose = document.getElementById("weapon-picker-close");
      const racePicker = document.getElementById("race-picker");
      const racePickerList = document.getElementById("race-picker-list");
      const raceSearch = document.getElementById("race-search");
      const racePickerAdd = document.getElementById("race-picker-add");
      const racePickerClose = document.getElementById("race-picker-close");
      const sizePicker = document.getElementById("size-picker");
      const sizePickerList = document.getElementById("size-picker-list");
      const sizePickerClose = document.getElementById("size-picker-close");
      const alignmentPicker = document.getElementById("alignment-picker");
      const alignmentPickerList = document.getElementById("alignment-picker-list");
      const alignmentPickerClose = document.getElementById("alignment-picker-close");
      const spellPicker = document.getElementById("spell-picker");
      const spellPickerList = document.getElementById("spell-picker-list");
      const spellSearch = document.getElementById("spell-search");
      const spellPickerAdd = document.getElementById("spell-picker-add");
      const spellPickerClose = document.getElementById("spell-picker-close");
      const classPicker = document.getElementById("class-picker");
      const classPickerList = document.getElementById("class-picker-list");
      const classSearch = document.getElementById("class-search");
      const classPickerAdd = document.getElementById("class-picker-add");
      const classPickerClose = document.getElementById("class-picker-close");
      const classEquipmentPicker = document.getElementById("class-equipment-picker");
      const classEquipmentBody = document.getElementById("class-equipment-body");
      const classEquipmentApply = document.getElementById("class-equipment-apply");
      const classEquipmentClose = document.getElementById("class-equipment-close");
      const backgroundPicker = document.getElementById("background-picker");
      const backgroundPickerList = document.getElementById("background-picker-list");
      const backgroundSearch = document.getElementById("background-search");
      const backgroundPickerAdd = document.getElementById("background-picker-add");
      const backgroundPickerClose = document.getElementById("background-picker-close");
      const backgroundConfigPicker = document.getElementById("background-config-picker");
      const backgroundConfigBody = document.getElementById("background-config-body");
      const backgroundConfigApply = document.getElementById("background-config-apply");
      const backgroundConfigClose = document.getElementById("background-config-close");
      const itemPicker = document.getElementById("item-picker");
      const itemPickerList = document.getElementById("item-picker-list");
      const itemSearch = document.getElementById("item-search");
      const itemPickerAdd = document.getElementById("item-picker-add");
      const itemPickerClose = document.getElementById("item-picker-close");
      const cantripPanel = document.getElementById("spell-panel-1");
      const itemPanel = document.getElementById("item-panel");
      const itemPanelTitle = document.getElementById("item-panel-title");
      const itemPanelBody = document.getElementById("item-panel-body");
      const itemPanelClose = document.getElementById("item-panel-close");
      const equipmentListEl = document.getElementById("equipment-list");
      const itemsListEl = document.getElementById("items-list");
      let equipmentItems = [];
      let inventoryItems = [];
      let cantripItems = [];
      let activeWeaponName = "";
      let pickerSelected = "";
      let cantripSelected = "";
      let itemSelected = "";
      let raceSelected = "";
      let sizeSelected = "";
      let backgroundSelected = "";
      let equippedMainId = "";
      let equippedOffhandId = "";
      let equippedMainTwoHanded = false;
      let equippedArmorId = "";
      let equippedShieldId = "";
      let isRemoteUpdate = false;
      let saveTimer = null;
      let currentRaceSpeed = "";
      let currentRaceSizes = [];
      let suppressAbilityScoreDefaults = false;
      const LOCAL_SHEET_STORAGE_KEY = "dnd_sheet_local_v1";
      const DEFAULT_ABILITY_SCORE = 10;
      const DEFAULT_LEVEL = 10;
      const DEFAULT_XP = 10;

      function toNumber(value) {
        const num = Number(value);
        return Number.isFinite(num) ? num : 0;
      }

      function formatMod(num) {
        if (!Number.isFinite(num)) return "";
        return num >= 0 ? `+${num}` : `${num}`;
      }

      function setListValue(el, value) {
        if (!el) return;
        if ("value" in el) {
          el.value = value;
          return;
        }
        el.textContent = value;
      }

      function getListValue(el) {
        if (!el) return "";
        if ("value" in el) {
          return el.value;
        }
        return el.textContent || "";
      }

      function computeAbilityMod(score) {
        if (!Number.isFinite(score)) return 0;
        return Math.floor((score - 10) / 2);
      }

      function isBlankValue(value) {
        return value === undefined || value === null || String(value).trim() === "";
      }

      function applyBaseDefaults() {
        if (!suppressAbilityScoreDefaults) {
          Object.values(abilityScores).forEach((el) => {
            if (!el) return;
            if (isBlankValue(getListValue(el))) {
              setListValue(el, String(DEFAULT_ABILITY_SCORE));
            }
          });
        }
        if (levelEl && isBlankValue(getListValue(levelEl))) {
          setListValue(levelEl, String(DEFAULT_LEVEL));
        }
        if (xpInput && isBlankValue(getListValue(xpInput))) {
          setListValue(xpInput, String(DEFAULT_XP));
        }
      }

      function getFieldValue(el) {
        if (el.type === "checkbox") {
          return el.checked;
        }
        return el.value;
      }

      function applyFieldValue(el, value) {
        if (value === undefined) return;
        if (el.type === "checkbox") {
          el.checked = Boolean(value);
          return;
        }
        el.value = value;
      }

      const proficiencyByLevel = [
        2, 2, 2, 2,
        3, 3, 3, 3,
        4, 4, 4, 4,
        5, 5, 5, 5,
        6, 6, 6, 6,
      ];

      function recalcDerived() {
        const levelRaw = toNumber(getListValue(levelEl));
        const level = Math.min(Math.max(levelRaw || DEFAULT_LEVEL, 1), 20);
        const profBonus = proficiencyByLevel[level - 1] ?? 2;
        if (proficiencyBonusEl) {
          proficiencyBonusEl.value = formatMod(profBonus);
        }
        const mods = {};
        Object.entries(abilityScores).forEach(([ability, scoreEl]) => {
          const score = toNumber(getListValue(scoreEl));
          const mod = computeAbilityMod(score);
          mods[ability] = mod;
          if (abilityMods[ability]) {
            setListValue(abilityMods[ability], formatMod(mod));
          }
        });

        saveRows.forEach((row) => {
          const ability = row.dataset.ability;
          const checkbox = row.querySelector("input[type='checkbox']");
          const valueEl = row.querySelector(".save-value");
          const base = mods[ability] ?? 0;
          const total = base + (checkbox?.checked ? profBonus : 0);
          setListValue(valueEl, formatMod(total));
        });

        skillRows.forEach((row) => {
          const ability = row.dataset.ability;
          const checkbox = row.querySelector("input[type='checkbox']");
          const valueEl = row.querySelector(".skill-value");
          const base = mods[ability] ?? 0;
          const total = base + (checkbox?.checked ? profBonus : 0);
          setListValue(valueEl, formatMod(total));
        });

        updateArmorClass(mods);
        if (initiativeEl) {
          setListValue(initiativeEl, formatMod(mods.dex ?? 0));
        }
        if (classesLoaded && classInput?.value) {
          const classEntry = classByName.get(classInput.value);
          if (classEntry) {
            updateTotalHpForClass(classEntry, mods);
          }
        }

        if (passivePerceptionEl) {
          const perceptionRow = skillRows.find(
            (row) => row.textContent && row.textContent.includes("Perception")
          );
          const perceptionValueEl = perceptionRow?.querySelector(".skill-value");
          const perceptionMod = toNumber(getListValue(perceptionValueEl));
          setListValue(passivePerceptionEl, String(10 + perceptionMod));
        }

        if (!isRemoteUpdate) {
          scheduleSave();
        }
      }

      function updateArmorClass(mods = {}) {
        const dex = mods.dex ?? computeAbilityMod(toNumber(getListValue(abilityScores.dex)));
        const con = mods.con ?? computeAbilityMod(toNumber(getListValue(abilityScores.con)));
        const wis = mods.wis ?? computeAbilityMod(toNumber(getListValue(abilityScores.wis)));
        const className = String(classInput?.value || "").toLowerCase();
        const equippedArmor = getEquippedArmorById(equippedArmorId)?.armor || null;
        const equippedShield = getEquippedArmorById(equippedShieldId)?.armor || null;

        let acBase = 10 + dex;
        if (equippedArmor) {
          const dexAllowed = equippedArmor.dexBonus?.allowed !== false;
          const dexMax = equippedArmor.dexBonus?.max;
          const dexBonus = dexAllowed
            ? (Number.isFinite(Number(dexMax)) ? Math.min(dex, Number(dexMax)) : dex)
            : 0;
          acBase = (Number(equippedArmor.baseAC) || 10) + dexBonus;
        } else if (className.includes("barbarian")) {
          acBase = 10 + dex + con;
        } else if (className.includes("monk")) {
          acBase = 10 + dex + wis;
        }
        const shieldBonus = equippedShield ? (Number(equippedShield.baseAC) || 2) : 0;
        setListValue(armorClassEl, String(acBase + shieldBonus));
      }

      function adjustLevel(delta) {
        const current = toNumber(getListValue(levelEl)) || 1;
        const next = Math.min(20, Math.max(1, current + delta));
        if (next === current) return;
        setListValue(levelEl, String(next));
        recalcDerived();
      }

      let weaponTable = [];
      let weaponByName = new Map();
      let weaponList = [];
      let weaponsLoaded = false;
      let armorTable = [];
      let armorByName = new Map();
      let armorsLoaded = false;
      let cantripTable = [];
      let cantripByName = new Map();
      let cantripList = [];
      let cantripsLoaded = false;
      let itemTable = [];
      let itemByName = new Map();
      let itemsLoaded = false;
      let traitByName = new Map();
      let traitsLoaded = false;
      let raceTable = [];
      let raceByName = new Map();
      let raceList = [];
      let racesLoaded = false;
      let backgroundTable = [];
      let backgroundByName = new Map();
      let backgroundList = [];
      let backgroundsLoaded = false;
      let classTable = [];
      let classByName = new Map();
      let classList = [];
      let classesLoaded = false;
      let classSelected = "";
      let pendingBackgroundEntry = null;
      let pendingBackgroundAbilityMode = 0;
      let pendingBackgroundAbilityAssignments = [];
      let pendingBackgroundEquipmentChoice = "A";
      let appliedBackgroundName = "";
      let appliedBackgroundAbilityBonuses = {
        str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0,
      };
      let appliedBackgroundSkillIds = [];
      let appliedBackgroundInventoryNames = [];
      let appliedBackgroundEquipmentIds = [];
      let pendingClassEquipmentEntry = null;
      let pendingClassEquipmentSelections = [];
      let appliedClassEquipmentName = "";
      let appliedClassInventoryNames = [];
      let appliedClassEquipmentIds = [];
      let currentWeaponProficiencies = [];

      function refreshWeaponIndex() {
        weaponByName = new Map(weaponTable.map((weapon) => [weapon.name, weapon]));
        weaponList = weaponTable.map((weapon) => weapon.name);
      }

      function refreshArmorIndex() {
        armorByName = new Map(armorTable.map((armor) => [armor.name, armor]));
      }

      function refreshCantripIndex() {
        cantripByName = new Map(cantripTable.map((spell) => [spell.name, spell]));
        cantripList = cantripTable.map((spell) => spell.name);
      }

      function refreshClassIndex() {
        classByName = new Map(classTable.map((entry) => [entry.name, entry]));
        classList = classTable.map((entry) => entry.name);
      }

      function refreshBackgroundIndex() {
        backgroundByName = new Map(backgroundTable.map((entry) => [entry.name, entry]));
        backgroundList = backgroundTable.map((entry) => entry.name);
      }

      function normalizeRaceSizes(value) {
        if (Array.isArray(value)) {
          return value.map((entry) => String(entry || "").trim()).filter(Boolean);
        }
        if (value === null || value === undefined) return [];
        const text = String(value).trim();
        return text ? [text] : [];
      }

      function normalizeRaceSpeed(value) {
        const num = Number(value);
        return Number.isFinite(num) ? num : "";
      }

      function normalizeGoldValue(value) {
        const text = String(value ?? "").trim();
        if (!text) return "";
        const num = Number(text.replace(/[^0-9.-]/g, ""));
        return Number.isFinite(num) ? num : text;
      }

      function formatGoldValue(value) {
        if (typeof value === "number" && Number.isFinite(value)) {
          return `${value} gp`;
        }
        const text = String(value ?? "").trim();
        return text || "--";
      }

      function normalizeKey(value) {
        return String(value || "")
          .trim()
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, " ")
          .trim();
      }

      function firstNonBlank(values = []) {
        for (const value of values) {
          if (value === undefined || value === null) continue;
          const text = Array.isArray(value) ? value.join(" ").trim() : String(value).trim();
          if (text) return text;
        }
        return "";
      }

      function normalizeTagList(values) {
        if (!Array.isArray(values)) return [];
        return values
          .map((value) => String(value || "").trim().toLowerCase())
          .filter(Boolean);
      }

      function normalizeSingleTag(value) {
        return String(value || "").trim().toLowerCase();
      }

      function getSelectedTagSetFromInputs(ids = []) {
        const tags = new Set();
        ids.forEach((id) => {
          const input = document.getElementById(id);
          if (!input || !("value" in input)) return;
          String(input.value || "")
            .split(/[,\n;|/]+/)
            .map((entry) => entry.trim().toLowerCase())
            .filter(Boolean)
            .forEach((entry) => tags.add(entry));
        });
        return tags;
      }

      function raceTagMatches(cantripSpecies, selectedRace) {
        if (!selectedRace) return false;
        const race = selectedRace.toLowerCase();
        return cantripSpecies.some((entry) =>
          entry === race || entry.startsWith(`${race} (`) || entry.includes(race)
        );
      }

      function subclassTagMatches(cantripSubclasses, selectedClass, selectedSubclasses) {
        if (!cantripSubclasses.length || !selectedSubclasses.size) return false;
        const classKey = selectedClass.toLowerCase();
        return cantripSubclasses.some((entry) => {
          const [entryClassRaw, entrySubclassRaw] = entry.split(":");
          const entryClass = String(entryClassRaw || "").trim().toLowerCase();
          const entrySubclass = String(entrySubclassRaw || "").trim().toLowerCase();
          if (!entryClass) return false;
          if (entryClass && classKey && entryClass !== classKey) return false;
          return (
            selectedSubclasses.has(entrySubclass) ||
            selectedSubclasses.has(`${entryClass}: ${entrySubclass}`.trim())
          );
        });
      }

      function featTagMatches(cantripFeats, selectedFeats) {
        if (!cantripFeats.length || !selectedFeats.size) return false;
        return cantripFeats.some((entry) => selectedFeats.has(entry));
      }

      function backgroundTagMatches(cantripBackgrounds, selectedBackground) {
        if (!cantripBackgrounds.length || !selectedBackground) return false;
        return cantripBackgrounds.some((entry) => entry === selectedBackground);
      }

      function getSelectedSubclassTags() {
        return getSelectedTagSetFromInputs(["subclass", "class-subclass", "subclass-level"]);
      }

      function getSelectedFeatTags() {
        return getSelectedTagSetFromInputs(["feats", "feat", "character-feats"]);
      }

      function cantripAllowedForCharacter(spell) {
        const selectedClass = String(classInput?.value || "").trim().toLowerCase();
        const selectedRace = String(raceInput?.value || "").trim().toLowerCase();
        const selectedBackground = normalizeSingleTag(backgroundInput?.value || "");
        const selectedSubclasses = getSelectedSubclassTags();
        const selectedFeats = getSelectedFeatTags();

        const cantripClasses = normalizeTagList(spell.classes);
        const cantripSubclasses = normalizeTagList(spell.subclasses);
        const cantripSpecies = normalizeTagList(spell.species);
        const cantripFeats = normalizeTagList(spell.feats);
        const cantripBackgrounds = normalizeTagList(spell.backgrounds);

        const hasRestrictions =
          cantripClasses.length ||
          cantripSubclasses.length ||
          cantripSpecies.length ||
          cantripFeats.length ||
          cantripBackgrounds.length;
        if (!hasRestrictions) return true;
        if (!selectedClass && !selectedRace && !selectedBackground && !selectedSubclasses.size && !selectedFeats.size) {
          return true;
        }

        if (selectedClass && cantripClasses.includes(selectedClass)) return true;
        if (selectedClass && subclassTagMatches(cantripSubclasses, selectedClass, selectedSubclasses)) return true;
        if (selectedRace && raceTagMatches(cantripSpecies, selectedRace)) return true;
        if (featTagMatches(cantripFeats, selectedFeats)) return true;
        if (backgroundTagMatches(cantripBackgrounds, selectedBackground)) return true;

        return false;
      }

      function refreshRaceIndex() {
        raceByName = new Map(raceTable.map((race) => [race.name, race]));
        raceList = raceTable.map((race) => race.name);
      }

      function refreshItemIndex() {
        itemByName = new Map();
        itemTable.forEach((item) => {
          itemByName.set(item.name, item);
          itemByName.set(normalizeKey(item.name), item);
        });
      }

      async function loadWeapons() {
        try {
          const snapshot = await getDocs(collection(db, "weapons"));
          weaponTable = snapshot.docs
            .map((docSnap) => {
              const data = docSnap.data() || {};
              const name = (data.name || docSnap.id || "").trim();
              if (!name) return null;
              return {
                name,
                category: (data.category || "").trim(),
                damage: (data.damage || "").trim(),
                properties: (data.properties || "???").trim(),
                mastery: (data.mastery || "???").trim(),
                weight: (data.weight || "???").trim(),
                cost: (data.cost || "???").trim(),
              };
            })
            .filter(Boolean);
          refreshWeaponIndex();
          weaponsLoaded = true;
          window.weaponTable = weaponTable;
          window.weaponByName = weaponByName;
        } catch (error) {
          console.error("Failed to load weapons", error);
          weaponsLoaded = true;
        }
      }

      async function loadArmors() {
        try {
          const response = await fetch("./Data/armors.json");
          if (!response.ok) {
            throw new Error(`Armor fetch failed: ${response.status}`);
          }
          const data = await response.json();
          armorTable = Object.values(data || {})
            .map((entry) => {
              const name = (entry?.name || "").trim();
              if (!name) return null;
              return {
                name,
                type: (entry.type || "").trim(),
                baseAC: Number(entry.baseAC) || 0,
                dexBonus: entry.dexBonus || { allowed: true, max: null },
                strengthRequirement: entry.strengthRequirement ?? null,
                stealthDisadvantage: Boolean(entry.stealthDisadvantage),
                weightLb: entry.weightLb ?? null,
                costGp: entry.costGp ?? null,
                donTimeMinutes: entry.donTimeMinutes ?? null,
                doffTimeMinutes: entry.doffTimeMinutes ?? null,
                isShield: Boolean(entry.isShield),
              };
            })
            .filter(Boolean);
          refreshArmorIndex();
          armorsLoaded = true;
        } catch (error) {
          console.error("Failed to load armors", error);
          armorsLoaded = true;
        }
      }

      async function loadCantrips() {
        try {
          const response = await fetch("./Data/cantrips.json");
          if (!response.ok) {
            throw new Error(`Cantrip fetch failed: ${response.status}`);
          }
          const data = await response.json();
          cantripTable = Object.values(data || {})
            .map((entry) => {
              const name = (entry?.name || "").trim();
              if (!name) return null;
              return {
                name,
                school: (entry.school || "").trim(),
                level: (entry.level || "").trim(),
                range: (entry.range || "").trim(),
                components: (entry.components || "").trim(),
                duration: (entry.duration || "").trim(),
                description: (entry.description || "").trim(),
                classes: Array.isArray(entry.classes) ? entry.classes.slice() : [],
                subclasses: Array.isArray(entry.subclasses) ? entry.subclasses.slice() : [],
                species: Array.isArray(entry.species) ? entry.species.slice() : [],
                feats: Array.isArray(entry.feats) ? entry.feats.slice() : [],
                backgrounds: Array.isArray(entry.backgrounds) ? entry.backgrounds.slice() : [],
              };
            })
            .filter(Boolean);
          refreshCantripIndex();
          cantripsLoaded = true;
          renderCantrips();
        } catch (error) {
          console.error("Failed to load cantrips", error);
          cantripsLoaded = true;
        }
      }

      async function loadClasses() {
        try {
          const response = await fetch("./Data/class.json");
          if (!response.ok) {
            throw new Error(`Class fetch failed: ${response.status}`);
          }
          const data = await response.json();
          classTable = Object.values(data || {})
            .map((entry) => {
              const name = (entry?.name || "").trim();
              if (!name) return null;
              return {
                name,
                description: (entry.description || "").trim(),
                subclasses: Array.isArray(entry.subclasses) ? entry.subclasses.slice() : [],
                primaryAbility: Array.isArray(entry["primary ability"])
                  ? entry["primary ability"].slice()
                  : [],
                hitPointDie: (entry["hit point die"] || "").trim(),
                hitPointDieModifier: (entry["hit point die modifier"] || "").trim(),
                hitPointPerAdditionalLevelDie: (entry["hit point per additional level die"] || "").trim(),
                savingThrows: Array.isArray(entry["saving throws proficiencies options"])
                  ? entry["saving throws proficiencies options"].slice()
                  : [],
                weaponProficiencies: Array.isArray(entry["weapon proficiencies"])
                  ? entry["weapon proficiencies"].slice()
                  : [],
                armorTraining: Array.isArray(entry["armor training"])
                  ? entry["armor training"].slice()
                  : [],
                startingEquipment: Array.isArray(entry["starting equipment"])
                  ? entry["starting equipment"].slice()
                  : [],
              };
            })
            .filter(Boolean);
          refreshClassIndex();
          classesLoaded = true;
        } catch (error) {
          console.error("Failed to load classes", error);
          classesLoaded = true;
        }
      }

      async function loadItems() {
        try {
          const snapshot = await getDocs(collection(db, "items"));
          itemTable = snapshot.docs
            .map((docSnap) => {
              const data = docSnap.data() || {};
              const name = firstNonBlank([data.name, data.item, data.title, docSnap.id]);
              if (!name) return null;
              const description = firstNonBlank([data.text, data.Text]);
              const goldValue = normalizeGoldValue(firstNonBlank([data.value, data.Value]));
              return { name, description, goldValue };
            })
            .filter(Boolean);
          refreshItemIndex();
          itemsLoaded = true;
        } catch (error) {
          console.error("Failed to load items", error);
          itemsLoaded = true;
        }
      }

      async function loadRaces() {
        try {
          const snapshot = await getDocs(collection(db, "races"));
          raceTable = snapshot.docs
            .map((docSnap) => {
              const data = docSnap.data() || {};
              const name = (data.name || docSnap.id || "").trim();
              if (!name) return null;
              return {
                name,
                speed: data.speed,
                size: normalizeRaceSizes(data.size),
                creatureType: Array.isArray(data.creatureType) ? data.creatureType.slice() : [],
                traits: Array.isArray(data.traits) ? data.traits.slice() : [],
                description: (data.description || "").trim(),
                subclass: Array.isArray(data.subclass) ? data.subclass.slice() : [],
              };
            })
            .filter(Boolean);
          refreshRaceIndex();
          racesLoaded = true;
        } catch (error) {
          console.error("Failed to load races", error);
          racesLoaded = true;
        }
      }

      async function loadBackgrounds() {
        try {
          const snapshot = await getDocs(collection(db, "backgrounds"));
          backgroundTable = snapshot.docs
            .map((docSnap) => {
              const data = docSnap.data() || {};
              const name = (data.name || docSnap.id || "").trim();
              if (!name) return null;
              return {
                name,
                ability: Array.isArray(data.ability) ? data.ability.slice() : [],
                feats: Array.isArray(data.feats) ? data.feats.slice() : [],
                skillProficiencies: Array.isArray(data.skillProficiencies)
                  ? data.skillProficiencies.slice()
                  : [],
                toolProficiencies: Array.isArray(data.toolProficiencies)
                  ? data.toolProficiencies.slice()
                  : [],
                startingEquipment: Array.isArray(data.startingEquipment)
                  ? data.startingEquipment.slice()
                  : [],
              };
            })
            .filter(Boolean);
          refreshBackgroundIndex();
          backgroundsLoaded = true;
        } catch (error) {
          console.error("Failed to load backgrounds", error);
          backgroundsLoaded = true;
        }
      }

      const weaponAliases = {
        "Crossbow, Light": "Light Crossbow",
        "Crossbow, Hand": "Hand Crossbow",
        "Crossbow, Heavy": "Heavy Crossbow",
      };
      const masteryDescriptions = {
        Cleave: "On a melee hit, you can make an extra attack vs a second creature within 5 ft and reach. No ability mod to that damage unless negative. Once per turn.",
        Graze: "On a miss, deal damage equal to the ability modifier used. Same damage type.",
        Nick: "The extra Light-weapon attack can be part of the Attack action instead of a Bonus Action. Once per turn.",
        Push: "On a hit, you can push a Large or smaller creature up to 10 ft away.",
        Sap: "On a hit, the target has disadvantage on its next attack roll before your next turn.",
        Slow: "On a hit, reduce target Speed by 10 ft until your next turn. Does not stack beyond 10 ft.",
        Topple: "On a hit, target makes a Con save (DC 8 + ability mod + prof). Fail: Prone.",
        Vex: "On a hit, you have advantage on your next attack roll vs that creature before your next turn ends.",
      };
      const propertyDescriptions = {
        Ammunition: "Requires ammo. Each attack expends one. You need a free hand to load a one-handed weapon.",
        Finesse: "Use STR or DEX for attack and damage; same mod for both.",
        Heavy: "Disadvantage on attacks if STR < 13 (melee) or DEX < 13 (ranged).",
        Light: "After attacking with a Light weapon, you can make one extra Light-weapon attack as a Bonus Action; no ability mod to that damage unless negative.",
        Loading: "You can fire only one piece of ammo per action/bonus action/reaction.",
        Range: "Normal/long range. Disadvantage beyond normal; can't attack beyond long.",
        Reach: "Adds 5 ft to your reach for attacks and opportunity attacks.",
        Thrown: "Can be thrown; draw it as part of the attack. Use the same ability mod as melee with it.",
        "Two-Handed": "Requires two hands to attack.",
        Versatile: "Use one or two hands. Parentheses show damage when used with two hands.",
      };

      function resolveWeaponName(name) {
        if (weaponByName.has(name)) return name;
        const alias = weaponAliases[name];
        return alias && weaponByName.has(alias) ? alias : name;
      }

      function getWeaponData(name) {
        const resolved = resolveWeaponName(name);
        return weaponByName.get(resolved) || null;
      }

      function getArmorData(name) {
        if (!name) return null;
        return armorByName.get(name) || null;
      }

      function getDamageDie(damage) {
        if (!damage) return "";
        return damage.split(" ")[0];
      }

      function getVersatileDie(properties) {
        if (!properties) return "";
        const text = String(properties);
        const match =
          text.match(/Versatile\s*\(([^)]+)\)/i) ||
          text.match(/Versatile\s*([0-9]+d[0-9]+)/i);
        if (!match) return "";
        return match[1].trim();
      }

      function isVersatileWeapon(weapon) {
        if (!weapon?.properties) return false;
        return /versatile/i.test(String(weapon.properties));
      }

      function getWeaponDamageDie(weapon, useTwoHands) {
        if (!weapon) return "";
        if (useTwoHands && isVersatileWeapon(weapon)) {
          return getVersatileDie(weapon.properties) || getDamageDie(weapon.damage);
        }
        return getDamageDie(weapon.damage);
      }

      function getTwoHandDamageDie(weapon, useTwoHands) {
        if (!weapon) return "";
        if (!useTwoHands) return getDamageDie(weapon.damage);
        if (isVersatileWeapon(weapon)) {
          return getVersatileDie(weapon.properties) || getDamageDie(weapon.damage);
        }
        return getDamageDie(weapon.damage);
      }

      function getWeaponAttackAbility(weapon) {
        if (!weapon) return "str";
        if (weapon.properties && weapon.properties.includes("Finesse")) return "finesse";
        if (weapon.category && weapon.category.includes("Ranged")) return "dex";
        return "str";
      }

      function isWeaponProficient(weapon) {
        if (!weapon) return false;
        const profs = (currentWeaponProficiencies || [])
          .map((entry) => String(entry || "").toLowerCase());
        if (!profs.length) return false;
        const name = String(weapon.name || "").toLowerCase();
        const category = String(weapon.category || "").toLowerCase();
        const properties = String(weapon.properties || "").toLowerCase();
        if (profs.some((entry) => entry === "all weapons" || entry === "all")) return true;
        if (profs.some((entry) => entry.includes("simple") && category.includes("simple"))) return true;
        if (profs.some((entry) => entry.includes("martial") && category.includes("martial"))) return true;
        if (profs.some((entry) => entry.includes("ranged") && category.includes("ranged"))) return true;
        if (profs.some((entry) => entry.includes("melee") && category.includes("melee"))) return true;
        if (profs.some((entry) => entry.includes("light") && properties.includes("light"))) return true;
        if (profs.some((entry) => entry.includes(name))) return true;
        const normalizedName = name.replace(/[^a-z0-9]+/g, " ").trim();
        if (profs.some((entry) => entry.replace(/[^a-z0-9]+/g, " ").trim() === normalizedName)) {
          return true;
        }
        const nameParts = normalizedName.split(" ").filter(Boolean);
        if (nameParts.length) {
          if (profs.some((entry) => entry.includes(nameParts[0]) && entry.includes(nameParts[nameParts.length - 1]))) {
            return true;
          }
        }
        return false;
      }

      function buildPropertiesTooltip(properties) {
        if (!properties || properties === "") return "No properties.";
        const parts = properties.split(",").map((part) => part.trim());
        return parts
          .map((part) => {
            const base = part.split(" (")[0].trim();
            const desc = propertyDescriptions[base] || "";
            const parenMatch = part.match(/\\(([^)]+)\\)/);
            const extra = parenMatch ? ` Range: ${parenMatch[1]}.` : "";
            return desc ? `${base}: ${desc}${extra}` : part;
          })
          .join(" ");
      }

      function getItemTooltip(label, value, weapon) {
        if (label === "Mastery") {
          return masteryDescriptions[weapon.mastery] || `Mastery: ${weapon.mastery}`;
        }
        if (label === "Properties") {
          return buildPropertiesTooltip(weapon.properties);
        }
        if (label === "Range") {
          return `Range: ${value} (normal/long).`;
        }
        return `${label}: ${value}`;
      }

      function formatSpellLevel(level) {
        if (!level && level !== 0) return "";
        const numeric = Number(level);
        if (Number.isFinite(numeric)) {
          return numeric === 0 ? "Cantrip" : `Level ${numeric}`;
        }
        return String(level);
      }

      function getSpellTooltip(label, value) {
        if (label === "Description") {
          return value || "No description.";
        }
        return `${label}: ${value}`;
      }

      function getRaceData(name) {
        if (!name) return null;
        return raceByName.get(name) || null;
      }

      function getBackgroundData(name) {
        if (!name) return null;
        return backgroundByName.get(name) || null;
      }

      function toDisplayName(value) {
        return String(value || "")
          .replace(/[_-]+/g, " ")
          .split(" ")
          .filter(Boolean)
          .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
          .join(" ");
      }

      function normalizeAbilityKey(value) {
        const key = String(value || "").trim().toLowerCase();
        const map = {
          str: "str",
          strength: "str",
          dex: "dex",
          dexterity: "dex",
          con: "con",
          constitution: "con",
          int: "int",
          intelligence: "int",
          wis: "wis",
          wisdom: "wis",
          cha: "cha",
          charisma: "cha",
        };
        return map[key] || "";
      }

      function abilityKeyToLabel(key) {
        const map = {
          str: "Strength",
          dex: "Dexterity",
          con: "Constitution",
          int: "Intelligence",
          wis: "Wisdom",
          cha: "Charisma",
        };
        return map[key] || key.toUpperCase();
      }

      function extractBackgroundFeatNames(entry) {
        const feats = Array.isArray(entry?.feats) ? entry.feats : [];
        const names = [];
        feats.forEach((group) => {
          if (!group || typeof group !== "object") return;
          Object.keys(group).forEach((raw) => {
            const core = String(raw).split("|")[0].split(";")[0].trim();
            if (core) names.push(toDisplayName(core));
          });
        });
        return names;
      }

      function extractBackgroundSkillNames(entry) {
        const rows = Array.isArray(entry?.skillProficiencies) ? entry.skillProficiencies : [];
        const names = [];
        rows.forEach((group) => {
          if (!group || typeof group !== "object") return;
          Object.entries(group).forEach(([key, value]) => {
            if (key === "choose") return;
            if (value) names.push(toDisplayName(key));
          });
        });
        return names;
      }

      function extractBackgroundToolNames(entry) {
        const rows = Array.isArray(entry?.toolProficiencies) ? entry.toolProficiencies : [];
        const names = [];
        rows.forEach((group) => {
          if (!group || typeof group !== "object") return;
          Object.entries(group).forEach(([key, value]) => {
            if (!value) return;
            names.push(toDisplayName(key));
          });
        });
        return names;
      }

      function formatCoinFromCopper(value) {
        const amount = Number(value);
        if (!Number.isFinite(amount)) return "";
        const gp = amount / 100;
        return `${Number.isInteger(gp) ? gp : gp.toFixed(2)} gp`;
      }

      function normalizeCatalogItemName(name) {
        const key = normalizeKey(name);
        const weapon = weaponTable.find((entry) => normalizeKey(entry.name) === key);
        if (weapon) return weapon.name;
        const armor = armorTable.find((entry) => normalizeKey(entry.name) === key);
        if (armor) return armor.name;
        return name;
      }

      function parseEquipmentChoiceItems(choiceItems = []) {
        const out = [];
        choiceItems.forEach((entry) => {
          if (!entry || typeof entry !== "object") return;
          if (entry.item) {
            const baseRaw = String(entry.item).split("|")[0].trim();
            const display = String(entry.displayName || baseRaw).trim();
            const normalized = normalizeCatalogItemName(toDisplayName(display));
            const qty = Math.max(1, Number(entry.quantity) || 1);
            out.push({ type: "item", name: normalized, qty });
            return;
          }
          if (entry.equipmentType) {
            out.push({ type: "item", name: toDisplayName(entry.equipmentType), qty: 1 });
            return;
          }
          if (entry.value !== undefined && entry.value !== null) {
            const coin = formatCoinFromCopper(entry.value);
            if (coin) out.push({ type: "item", name: coin, qty: 1 });
          }
        });
        return out;
      }

      function parseClassEquipmentLine(line) {
        const text = String(line || "").trim();
        if (!text) return { type: "fixed", value: "" };
        const matches = Array.from(
          text.matchAll(/\(([a-z])\)\s*([^()]+?)(?=(?:,\s*)?\([a-z]\)|$)/gi)
        );
        if (matches.length < 2) {
          return { type: "fixed", value: text };
        }
        const options = matches
          .map((match) => String(match[2] || "").trim())
          .map((part) =>
            part
              .replace(/^\s*(?:or\s+|and\s+|,\s*)/i, "")
              .replace(/\s*(?:,\s*or|,\s*and)\s*$/i, "")
              .trim()
          )
          .filter(Boolean);
        if (!options.length) {
          return { type: "fixed", value: text };
        }
        return { type: "choice", options };
      }

      function splitClassEquipmentTextToEntries(text) {
        const raw = String(text || "").trim();
        if (!raw) return [];
        return raw
          .split(/\s*,\s*|\s+and\s+/i)
          .map((entry) => entry.replace(/\(if proficient\)/gi, "").trim())
          .filter(Boolean);
      }

      function normalizeClassEquipmentEntry(rawEntry) {
        const text = String(rawEntry || "").trim();
        if (!text) return { name: "", qty: 1 };
        const numberWords = {
          one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9, ten: 10,
        };
        const normalized = text.toLowerCase();
        const numMatch = normalized.match(/^(\d+)\s+(.+)$/);
        if (numMatch) {
          return { name: toDisplayName(numMatch[2]), qty: Math.max(1, Number(numMatch[1])) };
        }
        const wordMatch = normalized.match(/^(one|two|three|four|five|six|seven|eight|nine|ten)\s+(.+)$/);
        if (wordMatch) {
          return { name: toDisplayName(wordMatch[2]), qty: numberWords[wordMatch[1]] || 1 };
        }
        return {
          name: toDisplayName(normalized.replace(/^(a|an|any)\s+/i, "")),
          qty: 1,
        };
      }

      function revertClassStartingEquipmentEffects() {
        if (appliedClassInventoryNames.length) {
          appliedClassInventoryNames.forEach((name) => removeFirstInventoryEntryByName(name));
        }
        appliedClassInventoryNames = [];
        if (appliedClassEquipmentIds.length) {
          equipmentItems = equipmentItems.filter((item) => !appliedClassEquipmentIds.includes(item.id));
          if (appliedClassEquipmentIds.includes(equippedMainId)) equippedMainId = "";
          if (appliedClassEquipmentIds.includes(equippedOffhandId)) equippedOffhandId = "";
          if (appliedClassEquipmentIds.includes(equippedArmorId)) equippedArmorId = "";
          if (appliedClassEquipmentIds.includes(equippedShieldId)) equippedShieldId = "";
        }
        appliedClassEquipmentIds = [];
        appliedClassEquipmentName = "";
      }

      function summarizeEquipmentChoice(choiceItems = []) {
        const parsed = parseEquipmentChoiceItems(choiceItems);
        if (!parsed.length) return "--";
        return parsed
          .map((entry) => (entry.qty > 1 ? `${entry.name} x${entry.qty}` : entry.name))
          .join(", ");
      }

      function getBackgroundAbilityModes(entry) {
        const modes = [];
        const rows = Array.isArray(entry?.ability) ? entry.ability : [];
        rows.forEach((row) => {
          const weighted = row?.choose?.weighted;
          const from = Array.isArray(weighted?.from)
            ? weighted.from.map((value) => normalizeAbilityKey(value)).filter(Boolean)
            : [];
          const weights = Array.isArray(weighted?.weights)
            ? weighted.weights.map((value) => Number(value)).filter((value) => Number.isFinite(value) && value > 0)
            : [];
          if (!from.length || !weights.length) return;
          modes.push({ from, weights });
        });
        return modes;
      }

      function ensureUniqueAbilityAssignments(values = [], fallbackPool = []) {
        const used = new Set();
        return values.map((ability, idx) => {
          if (ability && !used.has(ability)) {
            used.add(ability);
            return ability;
          }
          const next = fallbackPool.find((candidate) => !used.has(candidate));
          if (next) {
            used.add(next);
            return next;
          }
          const backup = fallbackPool[idx] || fallbackPool[0] || "";
          if (backup) used.add(backup);
          return backup;
        });
      }

      function getSkillCheckboxId(skillName) {
        const key = normalizeKey(skillName).replace(/\s+/g, "-");
        return `skill-${key}-prof`;
      }

      function setBackgroundSkillProficiencies(skillNames = []) {
        const nextIds = skillNames
          .map((name) => getSkillCheckboxId(name))
          .filter(Boolean);
        skillRows.forEach((row) => {
          const checkbox = row.querySelector("input[type='checkbox']");
          if (!checkbox) return;
          checkbox.checked = nextIds.includes(checkbox.id);
          checkbox.disabled = true;
        });
        appliedBackgroundSkillIds = nextIds.slice();
      }

      function removeFirstInventoryEntryByName(name) {
        const key = normalizeKey(name);
        const idx = inventoryItems.findIndex((entry) => normalizeKey(entry) === key);
        if (idx >= 0) {
          inventoryItems.splice(idx, 1);
        }
      }

      function revertBackgroundEffects() {
        Object.entries(appliedBackgroundAbilityBonuses).forEach(([ability, bonus]) => {
          if (!bonus || !abilityScores[ability]) return;
          const current = toNumber(getListValue(abilityScores[ability]));
          setListValue(abilityScores[ability], String(current - bonus));
        });
        appliedBackgroundAbilityBonuses = {
          str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0,
        };

        skillRows.forEach((row) => {
          const checkbox = row.querySelector("input[type='checkbox']");
          if (!checkbox) return;
          checkbox.checked = false;
          checkbox.disabled = true;
        });
        appliedBackgroundSkillIds = [];

        if (appliedBackgroundInventoryNames.length) {
          appliedBackgroundInventoryNames.forEach((name) => removeFirstInventoryEntryByName(name));
        }
        appliedBackgroundInventoryNames = [];

        if (appliedBackgroundEquipmentIds.length) {
          equipmentItems = equipmentItems.filter((item) => !appliedBackgroundEquipmentIds.includes(item.id));
          if (appliedBackgroundEquipmentIds.includes(equippedMainId)) equippedMainId = "";
          if (appliedBackgroundEquipmentIds.includes(equippedOffhandId)) equippedOffhandId = "";
          if (appliedBackgroundEquipmentIds.includes(equippedArmorId)) equippedArmorId = "";
          if (appliedBackgroundEquipmentIds.includes(equippedShieldId)) equippedShieldId = "";
        }
        appliedBackgroundEquipmentIds = [];
        appliedBackgroundName = "";
      }

      function setSizePickerOpen(isOpen) {
        if (!sizePicker) return;
        sizePicker.classList.toggle("open", isOpen);
        sizePicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
      }

      function setAlignmentPickerOpen(isOpen) {
        if (!alignmentPicker) return;
        alignmentPicker.classList.toggle("open", isOpen);
        alignmentPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
      }

      function setAbilityPickerOpen(isOpen) {
        if (!abilityPicker) return;
        abilityPicker.classList.toggle("open", isOpen);
        abilityPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        if (!isOpen) {
          suppressAbilityScoreDefaults = false;
          applyBaseDefaults();
          recalcDerived();
        }
      }

      async function loadTraits() {
        try {
          const snapshot = await getDocs(collection(db, "traits"));
          const rows = snapshot.docs
            .map((docSnap) => {
              const data = docSnap.data() || {};
              const name = firstNonBlank([data.name, data.trait, data.title, docSnap.id]);
              if (!name) return null;
              const description = firstNonBlank([
                data.description,
                data.desc,
                data.details,
                data.text,
                data["trait description"],
                data.body,
              ]);
              return { name, description };
            })
            .filter(Boolean);
          traitByName = new Map();
          rows.forEach((row) => {
            traitByName.set(row.name, row);
            traitByName.set(normalizeKey(row.name), row);
          });
          traitsLoaded = true;
        } catch (error) {
          console.error("Failed to load traits", error);
          traitsLoaded = true;
        }
      }

      function getTraitData(name) {
        if (!name) return null;
        return traitByName.get(name) || traitByName.get(normalizeKey(name)) || null;
      }

      function getItemDataByName(name) {
        if (!name) return null;
        return itemByName.get(name) || itemByName.get(normalizeKey(name)) || null;
      }

      function openTraitPanel(name) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody || !name) return;
        const trait = getTraitData(name);
        const description = trait?.description || "No description found in Firestore traits table.";
        itemPanelTitle.textContent = trait?.name || name;
        itemPanelBody.innerHTML = "";
        const rows = [
          ["Trait", trait?.name || name],
          ["Description", description],
        ];
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          val.setAttribute("data-tooltip", `${label}: ${value}`);
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      function openInventoryItemPanel(name) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody || !name) return;
        const item = getItemDataByName(name);
        itemPanelTitle.textContent = item?.name || name;
        itemPanelBody.innerHTML = "";
        const rows = [
          ["Name", item?.name || name],
          ["Description", item?.description || "--"],
          ["Gold Value", formatGoldValue(item?.goldValue)],
        ];
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          val.setAttribute("data-tooltip", `${label}: ${value}`);
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      const standardArrayValues = [15, 14, 13, 12, 10, 8];
      let pendingClassEntry = null;
      let pendingAbilityValues = [];
      let pendingAbilitySelection = null;
      let abilityMethod = "standard";
      let currentRollValues = [];

      function roll4d6DropLowest() {
        const rolls = [];
        for (let i = 0; i < 4; i += 1) {
          rolls.push(Math.floor(Math.random() * 6) + 1);
        }
        rolls.sort((a, b) => a - b);
        return rolls.slice(1).reduce((sum, value) => sum + value, 0);
      }

      function resetAbilityAssignments() {
        Object.values(abilityScores).forEach((el) => {
          setListValue(el, "");
        });
        recalcDerived();
      }

      function buildAbilityPicker() {
        if (!abilityValuesEl || !abilityChoicesEl || !abilityOptionsEl) return;
        abilityValuesEl.innerHTML = "";
        abilityChoicesEl.innerHTML = "";
        abilityOptionsEl.innerHTML = "";

        const optionDefs = [
          { key: "standard", label: "Standard Array", enabled: true },
          { key: "pointbuy", label: "Point Buy", enabled: false },
          { key: "roll", label: "Roll", enabled: true },
        ];
        optionDefs.forEach((opt) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.textContent = opt.label;
          btn.disabled = !opt.enabled;
          if (abilityMethod === opt.key) {
            btn.classList.add("selected");
          }
          btn.addEventListener("click", () => {
            if (!opt.enabled) return;
            abilityMethod = opt.key;
            buildAbilityPicker();
          });
          abilityOptionsEl.appendChild(btn);
        });

        if (abilityMethod !== "standard") {
          if (abilityMethod === "roll") {
            if (!currentRollValues.length) {
              const rollBtn = document.createElement("button");
              rollBtn.type = "button";
              rollBtn.textContent = "Roll 4d6 (drop lowest) x6";
              rollBtn.addEventListener("click", () => {
                currentRollValues = Array.from({ length: 6 }, () => ({
                  id: `roll_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
                  value: roll4d6DropLowest(),
                }));
                pendingAbilitySelection = null;
                buildAbilityPicker();
              });
              abilityValuesEl.appendChild(rollBtn);
            }

            currentRollValues.forEach((entry) => {
              const btn = document.createElement("button");
              btn.type = "button";
              btn.textContent = String(entry.value);
              if (pendingAbilitySelection && pendingAbilitySelection.id === entry.id) {
                btn.classList.add("selected");
              }
              btn.addEventListener("click", () => {
                pendingAbilitySelection = { id: entry.id, value: entry.value };
                buildAbilityPicker();
              });
              abilityValuesEl.appendChild(btn);
            });
          }
        } else {
          pendingAbilityValues.forEach((value) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.textContent = String(value);
            if (pendingAbilitySelection === value) {
              btn.classList.add("selected");
            }
            btn.addEventListener("click", () => {
              pendingAbilitySelection = value;
              buildAbilityPicker();
            });
            abilityValuesEl.appendChild(btn);
          });
        }

        if (abilityMethod !== "standard" && abilityMethod !== "roll") {
          return;
        }

        const abilityLabels = [
          ["str", "Strength"],
          ["dex", "Dexterity"],
          ["con", "Constitution"],
          ["int", "Intelligence"],
          ["wis", "Wisdom"],
          ["cha", "Charisma"],
        ];
        abilityLabels.forEach(([key, label]) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.textContent = label;
          const scoreEl = abilityScores[key];
          if (scoreEl && getListValue(scoreEl)) {
            btn.disabled = true;
          }
          btn.addEventListener("click", () => {
            if (!pendingAbilitySelection || !scoreEl || getListValue(scoreEl)) return;
            const selectedValue =
              typeof pendingAbilitySelection === "object"
                ? pendingAbilitySelection.value
                : pendingAbilitySelection;
            setListValue(scoreEl, String(selectedValue));
            if (abilityMethod === "standard") {
              pendingAbilityValues = pendingAbilityValues.filter((v) => v !== pendingAbilitySelection);
            }
            if (abilityMethod === "roll") {
              currentRollValues = currentRollValues.filter(
                (entry) => entry.id !== pendingAbilitySelection.id
              );
            }
            pendingAbilitySelection = null;
            recalcDerived();
            const allFilled = Object.values(abilityScores).every((el) => Boolean(getListValue(el)));
            if (allFilled) {
              setAbilityPickerOpen(false);
              if (pendingClassEntry) {
                finalizeClassSelection(pendingClassEntry);
                pendingClassEntry = null;
              }
              return;
            }
            buildAbilityPicker();
          });
          abilityChoicesEl.appendChild(btn);
        });
      }

      function openAbilityPickerForClass(entry) {
        pendingClassEntry = entry;
        suppressAbilityScoreDefaults = true;
        pendingAbilityValues = standardArrayValues.slice();
        pendingAbilitySelection = null;
        abilityMethod = "standard";
        currentRollValues = [];
        resetAbilityAssignments();
        buildAbilityPicker();
        setAbilityPickerOpen(true);
      }

      const alignmentOptions = [
        "Lawful Good",
        "Neutral Good",
        "Chaotic Good",
        "Lawful Neutral",
        "Neutral",
        "Chaotic Neutral",
        "Lawful Evil",
        "Neutral Evil",
        "Chaotic Evil",
      ];

      function openAlignmentPicker() {
        if (!alignmentPickerList) return;
        alignmentPickerList.innerHTML = "";
        const list = document.createElement("div");
        list.className = "weapon-list";
        alignmentOptions.forEach((alignment) => {
          const option = document.createElement("div");
          option.className = "weapon-option";
          if (alignmentInput?.value === alignment) {
            option.classList.add("selected");
          }
          option.textContent = alignment;
          option.addEventListener("click", () => {
            if (alignmentInput) {
              alignmentInput.value = alignment;
            }
            setAlignmentPickerOpen(false);
            scheduleSave();
          });
          list.appendChild(option);
        });
        alignmentPickerList.appendChild(list);
        setAlignmentPickerOpen(true);
      }

      function openSizePicker(options) {
        if (!sizePickerList) return;
        sizeSelected = "";
        sizePickerList.innerHTML = "";
        const list = document.createElement("div");
        list.className = "weapon-list";
        options.forEach((size) => {
          const option = document.createElement("div");
          option.className = "weapon-option";
          option.textContent = size;
          option.addEventListener("click", () => {
            sizeSelected = size;
            if (sizeInput) {
              sizeInput.value = size;
            }
            setSizePickerOpen(false);
            scheduleSave();
          });
          list.appendChild(option);
        });
        sizePickerList.appendChild(list);
        setSizePickerOpen(true);
      }

      function applyRaceSelection(raceName, { promptForSize = false } = {}) {
        if (!racesLoaded) return;
        if (!raceName) {
          currentRaceSpeed = "";
          currentRaceSizes = [];
          if (speedInput) setListValue(speedInput, "");
          if (sizeInput) sizeInput.value = "";
          if (traitsListEl) traitsListEl.innerHTML = "";
          buildCantripPickerList(spellSearch?.value || "");
          return;
        }
        const race = getRaceData(raceName);
        if (!race) return;
        const speedValue = normalizeRaceSpeed(race.speed);
        currentRaceSpeed = speedValue;
        if (speedInput) {
          setListValue(speedInput, speedValue !== "" ? String(speedValue) : "");
        }
        const sizes = normalizeRaceSizes(race.size);
        currentRaceSizes = sizes;
        const traits = Array.isArray(race.traits) ? race.traits.slice() : [];
        if (traitsListEl) {
          traitsListEl.innerHTML = "";
          traits.filter(Boolean).forEach((trait) => {
            const item = document.createElement("li");
            item.textContent = trait;
            item.classList.add("trait-clickable");
            item.setAttribute("role", "button");
            item.setAttribute("tabindex", "0");
            const open = () => openTraitPanel(trait);
            item.addEventListener("click", open);
            item.addEventListener("keydown", (event) => {
              if (event.key === "Enter" || event.key === " ") {
                event.preventDefault();
                open();
              }
            });
            traitsListEl.appendChild(item);
          });
        }
        if (sizes.length <= 1) {
          if (sizeInput) sizeInput.value = sizes[0] || "";
          buildCantripPickerList(spellSearch?.value || "");
          return;
        }
        if (promptForSize) {
          openSizePicker(sizes);
          buildCantripPickerList(spellSearch?.value || "");
          return;
        }
        if (sizeInput && (!sizeInput.value || !sizes.includes(sizeInput.value))) {
          sizeInput.value = sizes[0];
        }
        buildCantripPickerList(spellSearch?.value || "");
      }

      function rollDiceDetailed(dice) {
        if (!dice) return 0;
        if (/^\d+$/.test(dice)) {
          const value = Number(dice);
          return { total: value, rolls: [value] };
        }
        const match = dice.match(/(\d+)d(\d+)/i);
        if (!match) return { total: 0, rolls: [] };
        const count = Number(match[1]);
        const sides = Number(match[2]);
        let total = 0;
        const rolls = [];
        for (let i = 0; i < count; i += 1) {
          const roll = Math.floor(Math.random() * sides) + 1;
          rolls.push(roll);
          total += roll;
        }
        return { total, rolls };
      }

      function playDiceSound() {
        if (!diceSoundEl) return;
        diceSoundEl.currentTime = 0;
        const playPromise = diceSoundEl.play();
        if (playPromise && typeof playPromise.catch === "function") {
          playPromise.catch(() => {});
        }
      }

      function normalizeHitDie(die) {
        const text = String(die || "").trim();
        if (!text) return "";
        if (/^\d+d\d+$/i.test(text)) return text;
        if (/^d\d+$/i.test(text)) return `1${text}`;
        return text;
      }

      function getMaxDieValue(dice) {
        if (!dice) return 0;
        const match = String(dice).match(/(\d+)d(\d+)/i);
        if (!match) return 0;
        const count = Number(match[1]);
        const sides = Number(match[2]);
        if (!Number.isFinite(count) || !Number.isFinite(sides)) return 0;
        return count * sides;
      }

      function getFixedHpPerLevel(entry) {
        const die = normalizeHitDie(entry?.hitPointPerAdditionalLevelDie || entry?.hitPointDie);
        if (!die) return 0;
        const match = String(die).match(/(\d+)d(\d+)/i);
        if (!match) return 0;
        const count = Number(match[1]);
        const sides = Number(match[2]);
        if (!Number.isFinite(count) || !Number.isFinite(sides)) return 0;
        return count * (Math.floor(sides / 2) + 1);
      }

      function updateTotalHpForClass(entry, mods = {}) {
        if (!entry || !totalHpInput) return;
        const level = Math.min(Math.max(toNumber(getListValue(levelEl)) || 1, 1), 20);
        const conMod =
          mods.con ?? computeAbilityMod(toNumber(getListValue(abilityScores.con)));
        const levelOneDie = normalizeHitDie(entry?.hitPointDie || entry?.hitPointPerAdditionalLevelDie);
        const levelOneMax = getMaxDieValue(levelOneDie);
        const fixedAverage = getFixedHpPerLevel(entry);
        if (!levelOneMax || !fixedAverage) return;
        const levelOneTotal = Math.max(1, levelOneMax + conMod);
        const perLevelGain = Math.max(1, fixedAverage + conMod);
        const total = levelOneTotal + Math.max(0, level - 1) * perLevelGain;
        setListValue(totalHpInput, String(total));
        if (currentHpInput) {
          const current = toNumber(currentHpInput.value);
          if (!currentHpInput.value || current === 0 || current > total) {
            currentHpInput.value = String(total);
          }
        }
      }

      function setSavingThrowProficiencies(options = []) {
        const optionSet = new Set(
          options.map((value) => String(value || "").trim().toLowerCase()).filter(Boolean)
        );
        const abilityNames = {
          str: "strength",
          dex: "dexterity",
          con: "constitution",
          int: "intelligence",
          wis: "wisdom",
          cha: "charisma",
        };
        saveRows.forEach((row) => {
          const ability = row.dataset.ability;
          const checkbox = row.querySelector("input[type='checkbox']");
          if (!checkbox) return;
          const name = abilityNames[ability];
          checkbox.checked = name ? optionSet.has(name) : false;
          checkbox.disabled = true;
        });
        recalcDerived();
      }

      function applyClassSelection(entry, { rollHp = false } = {}) {
        if (!entry) return;
        updateTotalHpForClass(entry);
        setSavingThrowProficiencies(entry.savingThrows || []);
        currentWeaponProficiencies = Array.isArray(entry.weaponProficiencies)
          ? entry.weaponProficiencies.slice()
          : [];
        if (proficienciesListEl) {
          proficienciesListEl.innerHTML = "";
          const weaponText = (entry.weaponProficiencies || []).join(", ") || "--";
          const armorText = (entry.armorTraining || []).join(", ") || "--";
          const weaponItem = document.createElement("li");
          weaponItem.textContent = `Weapons: ${weaponText}`;
          const armorItem = document.createElement("li");
          armorItem.textContent = `Armor: ${armorText}`;
          proficienciesListEl.appendChild(weaponItem);
          proficienciesListEl.appendChild(armorItem);
        }
        buildCantripPickerList(spellSearch?.value || "");
      }

      function finalizeClassSelection(entry) {
        if (!entry) return;
        if (alignmentInput) {
          alignmentInput.disabled = false;
        }
        if (xpInput) {
          setListValue(xpInput, String(DEFAULT_XP));
        }
        applyClassSelection(entry, { rollHp: true });
        openClassEquipmentPicker(entry);
        openAlignmentPicker();
        scheduleSave();
        openClassPanel(entry);
        if (itemPanel) {
          itemPanel.classList.remove("open");
          itemPanel.setAttribute("aria-hidden", "true");
        }
      }

      function rollDamage(dice, label, ability) {
        const detail = rollDiceDetailed(dice);
        playDiceSound();
        const abilityKey = ability === "finesse"
          ? (toNumber(getListValue(abilityMods.dex)) >= toNumber(getListValue(abilityMods.str)) ? "dex" : "str")
          : ability || "str";
        const modValue = toNumber(getListValue(abilityMods[abilityKey]));
        const total = detail.total + modValue;
        resultEl.textContent = `Rolling... (${detail.total})`;
        return setDoc(rollRef, {
          roll: detail.total,
          mod: modValue,
          value: total,
          label,
          parts: [
            { label: dice, value: detail.total, detail: detail.rolls.join("+") },
            { label: `${abilityKey.toUpperCase()} Mod`, value: modValue },
          ],
          by: "anonymous",
          at: serverTimestamp(),
        });
      }

      function renderEquipment() {
        if (!equipmentListEl) return;
        equipmentListEl.innerHTML = "";
        equipmentItems.forEach((item) => {
          const weapon = getWeaponData(item.name);
          const armor = getArmorData(item.name);
          const isArmor = Boolean(armor && !weapon);
          const displayName = weapon?.name || item.name;
          const isWeaponEquipped = item.id === equippedMainId || item.id === equippedOffhandId;
          const isArmorEquipped = isArmor
            ? (armor.isShield ? item.id === equippedShieldId : item.id === equippedArmorId)
            : false;
          const isEquipped = isWeaponEquipped || isArmorEquipped;
          const row = document.createElement("div");
          row.className = "equipment-item";
          if (displayName === activeWeaponName) {
            row.classList.add("active");
          }
          const equipBtn = document.createElement("button");
          equipBtn.type = "button";
          equipBtn.className = "equip-btn";
          if (isEquipped) {
            equipBtn.classList.add("equipped");
          }
          equipBtn.textContent = isEquipped ? "Unequip" : "Equip";
          equipBtn.addEventListener("click", () => {
            if (isArmor) {
              handleArmorEquipToggle(item);
              return;
            }
            handleEquipToggle(item);
          });
          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "equipment-remove";
          removeBtn.setAttribute("aria-label", `Remove ${displayName}`);
          removeBtn.textContent = "X";
          removeBtn.addEventListener("click", () => {
            const wasMain = item.id === equippedMainId;
            const wasOffhand = item.id === equippedOffhandId;
            const wasArmor = item.id === equippedArmorId;
            const wasShield = item.id === equippedShieldId;
            equipmentItems = equipmentItems.filter((entry) => entry.id !== item.id);
            if (wasMain) {
              equippedMainId = "";
              equippedMainTwoHanded = false;
            }
            if (wasOffhand) {
              equippedOffhandId = "";
            }
            if (wasArmor) {
              equippedArmorId = "";
            }
            if (wasShield) {
              equippedShieldId = "";
            }
            if (activeWeaponName === displayName) {
              activeWeaponName = equipmentItems[0]?.name || "";
            }
            setEquipStatus("");
            updateActiveWeaponLabel();
            renderEquipment();
            recalcDerived();
            scheduleSave();
          });
          row.appendChild(removeBtn);
          if (isEquipped) {
            row.appendChild(equipBtn);
          }
          const label = document.createElement("div");
          label.style.cursor = "pointer";
          label.textContent = displayName;
          label.addEventListener("click", () => {
            if (!isArmor) {
              activeWeaponName = displayName;
            }
            updateActiveWeaponLabel();
            renderEquipment();
            openItemPanel(displayName);
          });
          row.appendChild(label);
          if (item.id === equippedMainId || item.id === equippedOffhandId) {
            const badge = document.createElement("span");
            badge.className = "equip-badge";
            badge.textContent = item.id === equippedMainId ? "Main" : "Offhand";
            row.appendChild(badge);
          } else if (isArmor) {
            const badge = document.createElement("span");
            badge.className = "equip-badge";
            badge.textContent = armor.isShield
              ? (item.id === equippedShieldId ? "Shield" : "Shield")
              : (item.id === equippedArmorId ? "Worn" : "Armor");
            row.appendChild(badge);
          }
          const useTwoHands =
            item.id === equippedMainId && equippedMainTwoHanded && isVersatileWeapon(weapon);
          const dice = getTwoHandDamageDie(weapon, useTwoHands);
          if (dice && !isArmor) {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "equipment-dmg";
            btn.textContent = dice;
            btn.addEventListener("click", () => {
              const isEquipped = item.id === equippedMainId || item.id === equippedOffhandId;
              if (!isEquipped) {
                setEquipStatus("Equip this weapon before rolling damage.");
                return;
              }
              if (equippedMainTwoHanded && item.id !== equippedMainId) {
                setEquipStatus("You can't use an offhand weapon while using two hands.");
                return;
              }
              const currentWeapon = getWeaponData(item.name);
              const currentUseTwoHands =
                item.id === equippedMainId &&
                equippedMainTwoHanded &&
                isVersatileWeapon(currentWeapon);
              if (equippedMainTwoHanded && item.id === equippedMainId) {
                const isValidTwoHand =
                  isVersatileWeapon(currentWeapon) || currentWeapon?.properties.includes("Two-Handed");
                if (!isValidTwoHand) {
                  setEquipStatus("This weapon can't be used with two hands.");
                  return;
                }
              }
              const currentDice = getTwoHandDamageDie(currentWeapon, currentUseTwoHands);
              activeWeaponName = displayName;
              updateActiveWeaponLabel();
              renderEquipment();
              const ability = getWeaponAttackAbility(currentWeapon);
              const labelText = `${displayName} Damage (${currentDice})`;
              rollDamage(currentDice, labelText, ability);
            });
            row.appendChild(btn);
          } else {
            const spacer = document.createElement("div");
            spacer.textContent = "";
            row.appendChild(spacer);
          }
          if (!isEquipped && !isArmor) {
            row.appendChild(equipBtn);
          } else if (!isEquipped && isArmor) {
            row.appendChild(equipBtn);
          }
          if (!isArmor && isVersatileWeapon(weapon)) {
            const twoHandBtn = document.createElement("button");
            twoHandBtn.type = "button";
            twoHandBtn.className = "twohand-btn";
            const isActive = item.id === equippedMainId && equippedMainTwoHanded;
            if (isActive) {
              twoHandBtn.classList.add("active");
            }
            twoHandBtn.textContent = "Two Hands";
            twoHandBtn.disabled = item.id !== equippedMainId;
            twoHandBtn.addEventListener("click", () => {
              handleTwoHandToggle(item);
            });
            row.appendChild(twoHandBtn);
          }
          equipmentListEl.appendChild(row);
        });
      }

      function updateActiveWeaponLabel() {
        if (!activeWeaponLabel) return;
        const mainItem = equipmentItems.find((item) => item.id === equippedMainId);
        if (mainItem) {
          activeWeaponLabel.textContent = `Equipped: ${mainItem.name}${equippedMainTwoHanded ? " (Two Hands)" : ""}`;
          updateAttackRollLabel();
          return;
        }
        activeWeaponLabel.textContent = activeWeaponName
          ? `Active: ${activeWeaponName}`
          : "No weapon selected";
        updateAttackRollLabel();
      }

      function updateAttackRollLabel() {
        if (!attackRollBtn) return;
        const mainItem = getEquippedWeaponById(equippedMainId);
        const weaponName = mainItem?.name || "";
        const weapon = weaponName ? getWeaponData(weaponName) : null;
        if (!weapon) {
          attackRollBtn.textContent = "Hit";
          attackRollBtn.disabled = true;
          return;
        }
        attackRollBtn.disabled = false;
        const useTwoHands =
          mainItem && mainItem.id === equippedMainId && equippedMainTwoHanded && isVersatileWeapon(weapon);
        const dice = getWeaponDamageDie(weapon, useTwoHands);
        attackRollBtn.textContent = dice ? `Hit (${dice})` : "Hit";
      }

      function setEquipStatus(message = "") {
        if (!equipStatusEl) return;
        equipStatusEl.textContent = message;
      }

      function setPickerOpen(isOpen) {
        if (!weaponPicker) return;
        weaponPicker.classList.toggle("open", isOpen);
        weaponPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        if (isOpen) {
          pickerSelected = "";
          if (weaponPickerAdd) {
            weaponPickerAdd.disabled = true;
          }
        }
      }

      function setSpellPickerOpen(isOpen) {
        if (!spellPicker) return;
        spellPicker.classList.toggle("open", isOpen);
        spellPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        if (isOpen) {
          cantripSelected = "";
          if (spellPickerAdd) {
            spellPickerAdd.disabled = true;
          }
        }
      }

      function setRacePickerOpen(isOpen) {
        if (!racePicker) return;
        racePicker.classList.toggle("open", isOpen);
        racePicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        if (isOpen) {
          raceSelected = "";
          if (racePickerAdd) {
            racePickerAdd.disabled = true;
          }
        }
      }

      function setClassPickerOpen(isOpen) {
        if (!classPicker) return;
        classPicker.classList.toggle("open", isOpen);
        classPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        if (isOpen) {
          classSelected = "";
          if (classPickerAdd) {
            classPickerAdd.disabled = true;
          }
        }
      }

      function setClassEquipmentOpen(isOpen) {
        if (!classEquipmentPicker) return;
        classEquipmentPicker.classList.toggle("open", isOpen);
        classEquipmentPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        if (!isOpen) {
          pendingClassEquipmentEntry = null;
        }
      }

      function setBackgroundPickerOpen(isOpen) {
        if (!backgroundPicker) return;
        backgroundPicker.classList.toggle("open", isOpen);
        backgroundPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        if (isOpen) {
          backgroundSelected = "";
          if (backgroundPickerAdd) {
            backgroundPickerAdd.disabled = true;
          }
        }
      }

      function setBackgroundConfigOpen(isOpen) {
        if (!backgroundConfigPicker) return;
        backgroundConfigPicker.classList.toggle("open", isOpen);
        backgroundConfigPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        if (!isOpen) {
          pendingBackgroundEntry = null;
        }
      }

      function setItemPickerOpen(isOpen) {
        if (!itemPicker) return;
        itemPicker.classList.toggle("open", isOpen);
        itemPicker.setAttribute("aria-hidden", isOpen ? "false" : "true");
        if (isOpen) {
          itemSelected = "";
          if (itemPickerAdd) {
            itemPickerAdd.disabled = true;
          }
        }
      }

      function createEquipmentItem(name) {
        return {
          id: `w_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
          name,
        };
      }

      function normalizeEquipmentItems(items) {
        if (!Array.isArray(items)) return [];
        if (items.length === 0) return [];
        if (typeof items[0] === "string") {
          return items.map((name) => createEquipmentItem(name));
        }
        return items.map((item) => ({
          id: item.id || createEquipmentItem(item.name || "Weapon").id,
          name: item.name || "Weapon",
        }));
      }

      function getEquippedWeaponById(id) {
        return equipmentItems.find((item) => item.id === id) || null;
      }

      function getEquippedArmorById(id) {
        if (!id) return null;
        const item = equipmentItems.find((entry) => entry.id === id);
        if (!item) return null;
        const armor = getArmorData(item.name);
        return armor ? { item, armor } : null;
      }

      function handleArmorEquipToggle(item) {
        const armor = getArmorData(item.name);
        if (!armor) return;
        if (armor.isShield) {
          if (item.id === equippedShieldId) {
            equippedShieldId = "";
            renderEquipment();
            recalcDerived();
            scheduleSave();
            return;
          }
          if (equippedMainTwoHanded) {
            setEquipStatus("You can't equip a shield while using two hands.");
            return;
          }
          if (equippedOffhandId) {
            setEquipStatus("Unequip offhand weapon before equipping a shield.");
            return;
          }
          equippedShieldId = item.id;
          renderEquipment();
          recalcDerived();
          scheduleSave();
          return;
        }

        if (item.id === equippedArmorId) {
          equippedArmorId = "";
          renderEquipment();
          recalcDerived();
          scheduleSave();
          return;
        }
        equippedArmorId = item.id;
        renderEquipment();
        recalcDerived();
        scheduleSave();
      }

      function handleEquipToggle(item) {
        const weapon = getWeaponData(item.name);
        if (!weapon) return;
        const isTwoHanded = weapon.properties.includes("Two-Handed");
        const isEquippedMain = item.id === equippedMainId;
        const isEquippedOff = item.id === equippedOffhandId;

        if (isEquippedMain || isEquippedOff) {
          if (isEquippedMain) {
            equippedMainId = "";
            equippedMainTwoHanded = false;
          } else {
            equippedOffhandId = "";
          }
          setEquipStatus("");
          renderEquipment();
          updateActiveWeaponLabel();
          scheduleSave();
          return;
        }

        if (isTwoHanded) {
          if (equippedMainId || equippedOffhandId || equippedShieldId) {
            setEquipStatus("Two-handed weapons require both hands.");
            return;
          }
          equippedMainId = item.id;
          equippedOffhandId = "";
          equippedMainTwoHanded = true;
          activeWeaponName = item.name;
          setEquipStatus("");
          renderEquipment();
          updateActiveWeaponLabel();
          scheduleSave();
          return;
        }

        if (!equippedMainId) {
          equippedMainId = item.id;
          equippedMainTwoHanded = false;
          activeWeaponName = item.name;
          setEquipStatus("");
          renderEquipment();
          updateActiveWeaponLabel();
          scheduleSave();
          return;
        }

        if (equippedMainTwoHanded) {
          setEquipStatus("You can't equip another weapon while using two hands.");
          return;
        }
        if (equippedShieldId) {
          setEquipStatus("Unequip shield before equipping an offhand weapon.");
          return;
        }

        const mainWeapon = getEquippedWeaponById(equippedMainId);
        const mainWeaponData = mainWeapon ? getWeaponData(mainWeapon.name) : null;
        const mainTwoHanded = mainWeaponData?.properties.includes("Two-Handed");
        if (mainTwoHanded) {
          setEquipStatus("You can't equip an offhand weapon while a two-handed weapon is equipped.");
          return;
        }

        if (!equippedOffhandId) {
          const mainIsLight = mainWeaponData?.properties.includes("Light");
          const offIsLight = weapon.properties.includes("Light");
          if (!mainIsLight || !offIsLight) {
            setEquipStatus("Offhand requires a Light weapon (unless you have a feature).");
            return;
          }
          equippedOffhandId = item.id;
          setEquipStatus("");
          renderEquipment();
          updateActiveWeaponLabel();
          scheduleSave();
          return;
        }

        setEquipStatus("You already have two weapons equipped.");
      }

      function handleTwoHandToggle(item) {
        if (item.id !== equippedMainId) {
          setEquipStatus("Two Hands only applies to the equipped main weapon.");
          return;
        }
        const weapon = getWeaponData(item.name);
        if (!weapon || !isVersatileWeapon(weapon)) return;
        if (equippedOffhandId) {
          setEquipStatus("You can't use two hands while an offhand weapon is equipped.");
          return;
        }
        if (equippedShieldId) {
          setEquipStatus("You can't use two hands while a shield is equipped.");
          return;
        }
        equippedMainTwoHanded = !equippedMainTwoHanded;
        setEquipStatus("");
        renderEquipment();
        updateActiveWeaponLabel();
        scheduleSave();
      }

      function buildWeaponPickerList(filterText = "") {
        if (!weaponPickerList) return;
        const filter = filterText.trim().toLowerCase();
        weaponPickerList.innerHTML = "";

        if (!weaponsLoaded || !armorsLoaded) {
          const loading = document.createElement("div");
          loading.className = "weapon-option";
          loading.textContent = "Loading equipment...";
          weaponPickerList.appendChild(loading);
          return;
        }
        if (!weaponTable.length && !armorTable.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No equipment found.";
          weaponPickerList.appendChild(empty);
          return;
        }

        const categoryOrder = [
          "Armor",
          "Simple Melee Weapons",
          "Simple Ranged Weapons",
          "Martial Melee Weapons",
          "Martial Ranged Weapons",
        ];

        const matchesFilter = (weapon) =>
          weapon.name.toLowerCase().includes(filter);

        const grouped = new Map();
        weaponTable.forEach((weapon) => {
          if (!matchesFilter(weapon)) return;
          const category = weapon.category || "Other";
          if (!grouped.has(category)) grouped.set(category, []);
          grouped.get(category).push(weapon);
        });
        armorTable.forEach((armor) => {
          if (!matchesFilter(armor)) return;
          const category = "Armor";
          if (!grouped.has(category)) grouped.set(category, []);
          grouped.get(category).push(armor);
        });

        const renderGroup = (category, entries) => {
          if (!entries.length) return;
          const header = document.createElement("div");
          header.className = "weapon-category";
          header.textContent = category;
          weaponPickerList.appendChild(header);

          const list = document.createElement("div");
          list.className = "weapon-list";
          entries
            .sort((a, b) => a.name.localeCompare(b.name))
            .forEach((entry) => {
              const option = document.createElement("div");
              option.className = "weapon-option";
              if (entry.name === pickerSelected) {
                option.classList.add("selected");
              }
              option.addEventListener("click", () => {
                pickerSelected = entry.name;
                if (weaponPickerAdd) {
                  weaponPickerAdd.disabled = false;
                }
                buildWeaponPickerList(weaponSearch?.value || "");
              });
              const name = document.createElement("strong");
              name.textContent = entry.name;
              const meta = document.createElement("span");
              if (category === "Armor") {
                const dexPart =
                  entry.dexBonus?.allowed
                    ? entry.dexBonus?.max === null
                      ? " + DEX"
                      : ` + DEX (max ${entry.dexBonus.max})`
                    : "";
                const cost = entry.costGp !== null && entry.costGp !== undefined ? `${entry.costGp} gp` : "--";
                meta.textContent = `AC ${entry.baseAC}${dexPart}  ${entry.type || "armor"}  ${cost}`;
              } else {
                const cost = entry.cost || "--";
                meta.textContent = `${entry.damage}  ${entry.properties === "" ? "No properties" : entry.properties}  ${cost}`;
              }
              option.appendChild(name);
              option.appendChild(meta);
              list.appendChild(option);
            });

          weaponPickerList.appendChild(list);
        };

        let rendered = false;
        categoryOrder.forEach((category) => {
          const weapons = grouped.get(category) || [];
          if (weapons.length) {
            renderGroup(category, weapons);
            rendered = true;
            grouped.delete(category);
          }
        });

        const remainingCategories = Array.from(grouped.keys()).sort((a, b) =>
          a.localeCompare(b)
        );
        remainingCategories.forEach((category) => {
          renderGroup(category, grouped.get(category) || []);
          rendered = true;
        });

        if (!rendered) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No equipment matches your search.";
          weaponPickerList.appendChild(empty);
        }
      }

      function buildCantripPickerList(filterText = "") {
        if (!spellPickerList) return;
        const filter = filterText.trim().toLowerCase();
        spellPickerList.innerHTML = "";

        if (!cantripsLoaded) {
          const loading = document.createElement("div");
          loading.className = "weapon-option";
          loading.textContent = "Loading cantrips...";
          spellPickerList.appendChild(loading);
          return;
        }

        if (!cantripTable.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No cantrips found.";
          spellPickerList.appendChild(empty);
          return;
        }

        const filtered = cantripTable.filter((spell) => {
          if (!cantripAllowedForCharacter(spell)) return false;
          if (!filter) return true;
          const nameMatch = spell.name.toLowerCase().includes(filter);
          const schoolMatch = spell.school.toLowerCase().includes(filter);
          return nameMatch || schoolMatch;
        });

        const grouped = new Map();
        filtered.forEach((spell) => {
          const school = spell.school || "Other";
          if (!grouped.has(school)) grouped.set(school, []);
          grouped.get(school).push(spell);
        });

        const schools = Array.from(grouped.keys()).sort((a, b) => a.localeCompare(b));
        let rendered = false;

        schools.forEach((school) => {
          const spells = grouped.get(school) || [];
          if (!spells.length) return;
          const header = document.createElement("div");
          header.className = "weapon-category";
          header.textContent = school;
          spellPickerList.appendChild(header);

          const list = document.createElement("div");
          list.className = "weapon-list";
          spells
            .slice()
            .sort((a, b) => a.name.localeCompare(b.name))
            .forEach((spell) => {
              const option = document.createElement("div");
              option.className = "weapon-option";
              if (spell.name === cantripSelected) {
                option.classList.add("selected");
              }
              option.addEventListener("click", () => {
                cantripSelected = spell.name;
                if (spellPickerAdd) {
                  spellPickerAdd.disabled = false;
                }
                openSpellPanel(spell);
                buildCantripPickerList(spellSearch?.value || "");
              });
              const name = document.createElement("strong");
              name.textContent = spell.name;
              const meta = document.createElement("span");
              const metaParts = [spell.school, spell.range].filter(Boolean);
              meta.textContent = metaParts.join("  ") || "No details";
              option.appendChild(name);
              option.appendChild(meta);
              list.appendChild(option);
            });

          spellPickerList.appendChild(list);
          rendered = true;
        });

        if (!rendered) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No cantrips match your search.";
          spellPickerList.appendChild(empty);
        }
      }

      function buildRacePickerList(filterText = "") {
        if (!racePickerList) return;
        const filter = filterText.trim().toLowerCase();
        racePickerList.innerHTML = "";

        if (!racesLoaded) {
          const loading = document.createElement("div");
          loading.className = "weapon-option";
          loading.textContent = "Loading races...";
          racePickerList.appendChild(loading);
          return;
        }

        if (!raceTable.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No races found.";
          racePickerList.appendChild(empty);
          return;
        }

        const races = raceList
          .filter((race) => race.toLowerCase().includes(filter))
          .sort((a, b) => a.localeCompare(b));

        if (!races.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No races match your search.";
          racePickerList.appendChild(empty);
          return;
        }

        const list = document.createElement("div");
        list.className = "weapon-list";
        races.forEach((race) => {
          const entry = raceByName.get(race);
          const option = document.createElement("div");
          option.className = "weapon-option";
          if (race === raceSelected) {
            option.classList.add("selected");
          }
          option.addEventListener("click", () => {
            raceSelected = race;
            if (racePickerAdd) {
              racePickerAdd.disabled = false;
            }
            if (entry) {
              openRacePanel(entry);
            }
            buildRacePickerList(raceSearch?.value || "");
          });
          const name = document.createElement("strong");
          name.textContent = race;
          option.appendChild(name);
          list.appendChild(option);
        });

        racePickerList.appendChild(list);
      }

      function buildClassPickerList(filterText = "") {
        if (!classPickerList) return;
        const filter = filterText.trim().toLowerCase();
        classPickerList.innerHTML = "";

        if (!classesLoaded) {
          const loading = document.createElement("div");
          loading.className = "weapon-option";
          loading.textContent = "Loading classes...";
          classPickerList.appendChild(loading);
          return;
        }

        if (!classTable.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No classes found.";
          classPickerList.appendChild(empty);
          return;
        }

        const filtered = classTable.filter((entry) => {
          if (!filter) return true;
          const nameMatch = entry.name.toLowerCase().includes(filter);
          const descMatch = entry.description.toLowerCase().includes(filter);
          return nameMatch || descMatch;
        });

        const list = document.createElement("div");
        list.className = "weapon-list";
        filtered
          .slice()
          .sort((a, b) => a.name.localeCompare(b.name))
          .forEach((entry) => {
            const option = document.createElement("div");
            option.className = "weapon-option";
            if (entry.name === classSelected) {
              option.classList.add("selected");
            }
            option.addEventListener("click", () => {
              classSelected = entry.name;
              if (classPickerAdd) {
                classPickerAdd.disabled = false;
              }
              openClassPanel(entry);
              buildClassPickerList(classSearch?.value || "");
            });
            const name = document.createElement("strong");
            name.textContent = entry.name;
            const meta = document.createElement("span");
            meta.textContent = entry.description || "No description";
            option.appendChild(name);
            option.appendChild(meta);
            list.appendChild(option);
          });

        if (!filtered.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No classes match your search.";
          classPickerList.appendChild(empty);
          return;
        }

        classPickerList.appendChild(list);
      }

      function buildClassEquipmentPicker(entry) {
        if (!classEquipmentBody || !entry) return;
        classEquipmentBody.innerHTML = "";
        const rows = Array.isArray(entry.startingEquipment) ? entry.startingEquipment : [];
        if (!rows.length) {
          const empty = document.createElement("div");
          empty.className = "spell-meta";
          empty.textContent = "No starting equipment listed for this class.";
          classEquipmentBody.appendChild(empty);
          return;
        }
        pendingClassEquipmentSelections = rows.map((line, idx) => {
          const parsed = parseClassEquipmentLine(line);
          if (parsed.type !== "choice") {
            return { type: "fixed", value: parsed.value };
          }
          const prev = pendingClassEquipmentSelections[idx];
          const selected = Number.isFinite(Number(prev?.selected))
            ? Math.max(0, Math.min(Number(prev.selected), parsed.options.length - 1))
            : 0;
          return { type: "choice", options: parsed.options.slice(), selected };
        });

        pendingClassEquipmentSelections.forEach((selection, idx) => {
          const card = document.createElement("div");
          card.className = "class-equipment-row";
          const title = document.createElement("h4");
          title.textContent = `Choice ${idx + 1}`;
          card.appendChild(title);
          if (selection.type === "fixed") {
            const text = document.createElement("div");
            text.textContent = selection.value || "--";
            card.appendChild(text);
          } else {
            const select = document.createElement("select");
            selection.options.forEach((optionText, optIdx) => {
              const option = document.createElement("option");
              option.value = String(optIdx);
              option.textContent = optionText;
              if (optIdx === selection.selected) option.selected = true;
              select.appendChild(option);
            });
            select.addEventListener("change", () => {
              selection.selected = Math.max(0, Number(select.value) || 0);
            });
            card.appendChild(select);
          }
          classEquipmentBody.appendChild(card);
        });
      }

      function applyClassStartingEquipment(entry) {
        if (!entry) return;
        revertClassStartingEquipmentEffects();
        const inventoryAdds = [];
        const equipmentAdds = [];
        pendingClassEquipmentSelections.forEach((selection) => {
          const text =
            selection.type === "choice"
              ? selection.options[selection.selected] || selection.options[0] || ""
              : selection.value;
          splitClassEquipmentTextToEntries(text).forEach((rawPiece) => {
            const normalized = normalizeClassEquipmentEntry(rawPiece);
            if (!normalized.name) return;
            const qty = Math.max(1, Number(normalized.qty) || 1);
            for (let idx = 0; idx < qty; idx += 1) {
              inventoryItems.push(normalized.name);
              inventoryAdds.push(normalized.name);
              if (getWeaponData(normalized.name) || getArmorData(normalized.name)) {
                const eq = createEquipmentItem(normalized.name);
                equipmentItems.push(eq);
                equipmentAdds.push(eq.id);
              }
            }
          });
        });
        appliedClassInventoryNames = inventoryAdds;
        appliedClassEquipmentIds = equipmentAdds;
        appliedClassEquipmentName = entry.name || "";
        renderInventoryItems();
        renderEquipment();
        recalcDerived();
      }

      function openClassEquipmentPicker(entry) {
        pendingClassEquipmentEntry = entry;
        pendingClassEquipmentSelections = [];
        buildClassEquipmentPicker(entry);
        setClassEquipmentOpen(true);
      }

      function buildBackgroundPickerList(filterText = "") {
        if (!backgroundPickerList) return;
        const filter = filterText.trim().toLowerCase();
        backgroundPickerList.innerHTML = "";

        if (!backgroundsLoaded) {
          const loading = document.createElement("div");
          loading.className = "weapon-option";
          loading.textContent = "Loading backgrounds...";
          backgroundPickerList.appendChild(loading);
          return;
        }

        if (!backgroundList.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No backgrounds found.";
          backgroundPickerList.appendChild(empty);
          return;
        }

        const filtered = backgroundList
          .filter((name) => !filter || name.toLowerCase().includes(filter))
          .sort((a, b) => a.localeCompare(b));

        if (!filtered.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No backgrounds match your search.";
          backgroundPickerList.appendChild(empty);
          return;
        }

        const list = document.createElement("div");
        list.className = "weapon-list";
        filtered.forEach((name) => {
          const entry = backgroundByName.get(name);
          const option = document.createElement("div");
          option.className = "weapon-option";
          if (name === backgroundSelected) {
            option.classList.add("selected");
          }
          option.addEventListener("click", () => {
            backgroundSelected = name;
            if (backgroundPickerAdd) backgroundPickerAdd.disabled = false;
            if (entry) openBackgroundPanel(entry);
            buildBackgroundPickerList(backgroundSearch?.value || "");
          });
          const strong = document.createElement("strong");
          strong.textContent = name;
          const skills = extractBackgroundSkillNames(entry);
          const meta = document.createElement("span");
          meta.textContent = skills.length
            ? `Skills: ${skills.join(", ")}`
            : "No skill data";
          option.appendChild(strong);
          option.appendChild(meta);
          list.appendChild(option);
        });
        backgroundPickerList.appendChild(list);
      }

      function buildBackgroundConfigPanel(entry) {
        if (!backgroundConfigBody || !entry) return;
        backgroundConfigBody.innerHTML = "";

        const abilitySection = document.createElement("div");
        abilitySection.className = "background-config-section";
        const abilityTitle = document.createElement("h4");
        abilityTitle.textContent = "Ability Score Increase";
        abilitySection.appendChild(abilityTitle);

        const modes = getBackgroundAbilityModes(entry);
        if (!modes.length) {
          const text = document.createElement("div");
          text.className = "spell-meta";
          text.textContent = "No ability choices.";
          abilitySection.appendChild(text);
        } else {
          pendingBackgroundAbilityMode = Math.max(
            0,
            Math.min(pendingBackgroundAbilityMode, modes.length - 1)
          );
          const currentMode = modes[pendingBackgroundAbilityMode];
          const modeButtons = document.createElement("div");
          modeButtons.className = "background-mode-options";
          modes.forEach((mode, idx) => {
            const btn = document.createElement("button");
            btn.type = "button";
            const weightLabel = mode.weights.map((value) => `+${value}`).join(" / ");
            btn.textContent = weightLabel;
            if (idx === pendingBackgroundAbilityMode) {
              btn.classList.add("selected");
            }
            btn.addEventListener("click", () => {
              pendingBackgroundAbilityMode = idx;
              pendingBackgroundAbilityAssignments = [];
              buildBackgroundConfigPanel(entry);
            });
            modeButtons.appendChild(btn);
          });
          abilitySection.appendChild(modeButtons);

          const defaults = currentMode.weights.map((_, idx) => currentMode.from[idx] || currentMode.from[0]);
          pendingBackgroundAbilityAssignments = ensureUniqueAbilityAssignments(
            pendingBackgroundAbilityAssignments.length ? pendingBackgroundAbilityAssignments : defaults,
            currentMode.from
          );

          currentMode.weights.forEach((weight, idx) => {
            const row = document.createElement("div");
            row.className = "background-choice-row";
            const label = document.createElement("label");
            label.textContent = `Choose ability for +${weight}`;
            const select = document.createElement("select");
            currentMode.from.forEach((ability) => {
              const option = document.createElement("option");
              option.value = ability;
              option.textContent = abilityKeyToLabel(ability);
              const takenByOther = pendingBackgroundAbilityAssignments.some(
                (assigned, assignedIdx) => assignedIdx !== idx && assigned === ability
              );
              option.disabled = takenByOther;
              if (pendingBackgroundAbilityAssignments[idx] === ability) {
                option.selected = true;
              }
              select.appendChild(option);
            });
            select.addEventListener("change", () => {
              pendingBackgroundAbilityAssignments[idx] = select.value;
              pendingBackgroundAbilityAssignments = ensureUniqueAbilityAssignments(
                pendingBackgroundAbilityAssignments,
                currentMode.from
              );
              buildBackgroundConfigPanel(entry);
            });
            row.appendChild(label);
            row.appendChild(select);
            abilitySection.appendChild(row);
          });
        }
        backgroundConfigBody.appendChild(abilitySection);

        const equipSection = document.createElement("div");
        equipSection.className = "background-config-section";
        const equipTitle = document.createElement("h4");
        equipTitle.textContent = "Starting Equipment";
        equipSection.appendChild(equipTitle);
        const choices = entry.startingEquipment?.[0] || {};
        const keys = Object.keys(choices);
        if (!keys.length) {
          const text = document.createElement("div");
          text.className = "spell-meta";
          text.textContent = "No equipment choices.";
          equipSection.appendChild(text);
        } else {
          if (!keys.includes(pendingBackgroundEquipmentChoice)) {
            pendingBackgroundEquipmentChoice = keys[0];
          }
          keys.forEach((key) => {
            const row = document.createElement("label");
            row.className = "background-choice-row";
            const input = document.createElement("input");
            input.type = "radio";
            input.name = "background-equip-choice";
            input.value = key;
            input.checked = pendingBackgroundEquipmentChoice === key;
            input.addEventListener("change", () => {
              pendingBackgroundEquipmentChoice = key;
            });
            const summary = summarizeEquipmentChoice(choices[key] || []);
            const text = document.createElement("span");
            text.textContent = `${key}: ${summary}`;
            row.appendChild(input);
            row.appendChild(text);
            equipSection.appendChild(row);
          });
        }
        backgroundConfigBody.appendChild(equipSection);

        const skillsSection = document.createElement("div");
        skillsSection.className = "background-config-section";
        const skillsTitle = document.createElement("h4");
        skillsTitle.textContent = "Skill Proficiencies";
        skillsSection.appendChild(skillsTitle);
        const skills = extractBackgroundSkillNames(entry);
        if (!skills.length) {
          const text = document.createElement("div");
          text.className = "spell-meta";
          text.textContent = "No skills configured.";
          skillsSection.appendChild(text);
        } else {
          const list = document.createElement("ul");
          list.className = "background-static-list";
          skills.forEach((skill) => {
            const li = document.createElement("li");
            li.textContent = skill;
            list.appendChild(li);
          });
          skillsSection.appendChild(list);
        }
        backgroundConfigBody.appendChild(skillsSection);
      }

      function applyBackgroundSelection(entry) {
        if (!entry) return;
        revertBackgroundEffects();

        const modes = getBackgroundAbilityModes(entry);
        if (modes.length) {
          const mode = modes[Math.max(0, Math.min(pendingBackgroundAbilityMode, modes.length - 1))];
          const selected = ensureUniqueAbilityAssignments(
            pendingBackgroundAbilityAssignments.slice(0, mode.weights.length),
            mode.from
          );
          const bonuses = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
          selected.forEach((ability, idx) => {
            if (!ability || !abilityScores[ability]) return;
            const bonus = Number(mode.weights[idx]) || 0;
            bonuses[ability] += bonus;
          });
          Object.entries(bonuses).forEach(([ability, bonus]) => {
            if (!bonus || !abilityScores[ability]) return;
            const current = toNumber(getListValue(abilityScores[ability]));
            setListValue(abilityScores[ability], String(current + bonus));
          });
          appliedBackgroundAbilityBonuses = bonuses;
        }

        const skills = extractBackgroundSkillNames(entry);
        setBackgroundSkillProficiencies(skills);

        const choiceSet = entry.startingEquipment?.[0] || {};
        const selectedChoice = choiceSet[pendingBackgroundEquipmentChoice] || [];
        const parsed = parseEquipmentChoiceItems(selectedChoice);
        const inventoryAdds = [];
        const equipmentAdds = [];
        parsed.forEach((row) => {
          const qty = Math.max(1, Number(row.qty) || 1);
          const isWeapon = Boolean(getWeaponData(row.name));
          const isArmor = Boolean(getArmorData(row.name));
          for (let idx = 0; idx < qty; idx += 1) {
            if (!isWeapon) {
              inventoryItems.push(row.name);
              inventoryAdds.push(row.name);
            }
            if (isWeapon || isArmor) {
              const eq = createEquipmentItem(row.name);
              equipmentItems.push(eq);
              equipmentAdds.push(eq.id);
            }
          }
        });
        appliedBackgroundInventoryNames = inventoryAdds;
        appliedBackgroundEquipmentIds = equipmentAdds;
        appliedBackgroundName = entry.name || "";

        renderInventoryItems();
        renderEquipment();
        recalcDerived();
        buildCantripPickerList(spellSearch?.value || "");
      }

      function openBackgroundConfig(entry) {
        pendingBackgroundEntry = entry;
        pendingBackgroundAbilityMode = 0;
        pendingBackgroundAbilityAssignments = [];
        pendingBackgroundEquipmentChoice = "A";
        buildBackgroundConfigPanel(entry);
        setBackgroundConfigOpen(true);
      }

      function initEquipmentWeapons() {
        if (addWeaponBtn) {
          addWeaponBtn.addEventListener("click", () => {
            setPickerOpen(true);
            buildWeaponPickerList(weaponSearch?.value || "");
          });
        }
        if (weaponSearch) {
          weaponSearch.addEventListener("input", () => {
            buildWeaponPickerList(weaponSearch.value);
          });
        }
        if (weaponPickerAdd) {
          weaponPickerAdd.addEventListener("click", () => {
            if (!pickerSelected) return;
            equipmentItems = [...equipmentItems, createEquipmentItem(pickerSelected)];
            activeWeaponName = pickerSelected;
            updateActiveWeaponLabel();
            renderEquipment();
            scheduleSave();
            setPickerOpen(false);
          });
        }
        if (weaponPickerClose) {
          weaponPickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setPickerOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            setPickerOpen(false);
          }
        });
        buildWeaponPickerList("");
        updateActiveWeaponLabel();
      }

      function normalizeCantripItems(items) {
        if (!Array.isArray(items)) return [];
        const seen = new Set();
        return items
          .map((entry) => (typeof entry === "string" ? entry.trim() : ""))
          .filter((name) => name && !seen.has(name) && seen.add(name));
      }

      function normalizeInventoryItems(items) {
        if (!Array.isArray(items)) return [];
        return items.flatMap((entry) => {
          if (typeof entry === "string") {
            const name = entry.trim();
            return name ? [name] : [];
          }
          if (!entry || typeof entry !== "object") return [];
          const name = String(entry.name || "").trim();
          if (!name) return [];
          const qty = Math.max(1, Math.floor(Number(entry.qty || 1)));
          return Array.from({ length: qty }, () => name);
        });
      }

      function removeInventoryItem(name) {
        const key = normalizeKey(name);
        inventoryItems = inventoryItems.filter((entry) => normalizeKey(entry) !== key);
        renderInventoryItems();
        scheduleSave();
      }

      function renderInventoryItems() {
        if (!itemsListEl) return;
        itemsListEl.innerHTML = "";
        if (!inventoryItems.length) {
          const empty = document.createElement("div");
          empty.className = "spell-meta";
          empty.textContent = "No items added.";
          itemsListEl.appendChild(empty);
          return;
        }

        const grouped = new Map();
        inventoryItems.forEach((name) => {
          const item = getItemDataByName(name) || { name, description: "", goldValue: "" };
          const key = normalizeKey(item.name || name);
          const existing = grouped.get(key);
          if (existing) {
            existing.qty += 1;
            return;
          }
          grouped.set(key, {
            key,
            name: item.name || name,
            description: item.description || "",
            goldValue: item.goldValue,
            qty: 1,
          });
        });

        const rows = Array.from(grouped.values()).sort((a, b) => a.name.localeCompare(b.name));
        const showQty = inventoryItems.length > 1;

        const header = document.createElement("div");
        header.className = `inventory-header${showQty ? " with-qty" : ""}`;
        header.innerHTML = showQty
          ? "<span>Name</span><span>Description</span><span>Gold</span><span>Qty</span><span>Action</span>"
          : "<span>Name</span><span>Description</span><span>Gold</span><span>Action</span>";
        itemsListEl.appendChild(header);

        rows.forEach((entry) => {
          const row = document.createElement("div");
          row.className = `inventory-row${showQty ? " with-qty" : ""}`;

          const nameEl = document.createElement("div");
          nameEl.className = "inventory-name";
          nameEl.textContent = entry.name;
          nameEl.addEventListener("click", () => openInventoryItemPanel(entry.name));

          const descEl = document.createElement("div");
          descEl.className = "inventory-desc";
          descEl.textContent = entry.description || "--";
          descEl.title = entry.description || "";

          const goldEl = document.createElement("div");
          goldEl.className = "inventory-gold";
          goldEl.textContent = formatGoldValue(entry.goldValue);

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "inventory-remove";
          removeBtn.textContent = "Remove";
          removeBtn.addEventListener("click", () => removeInventoryItem(entry.name));

          row.appendChild(nameEl);
          row.appendChild(descEl);
          row.appendChild(goldEl);
          if (showQty) {
            const qtyEl = document.createElement("div");
            qtyEl.className = "inventory-qty";
            qtyEl.textContent = String(entry.qty);
            row.appendChild(qtyEl);
          }
          row.appendChild(removeBtn);
          itemsListEl.appendChild(row);
        });
      }

      function buildItemPickerList(filterText = "") {
        if (!itemPickerList) return;
        const filter = filterText.trim().toLowerCase();
        itemPickerList.innerHTML = "";

        if (!itemsLoaded) {
          const loading = document.createElement("div");
          loading.className = "weapon-option";
          loading.textContent = "Loading items...";
          itemPickerList.appendChild(loading);
          return;
        }
        if (!itemTable.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No items found.";
          itemPickerList.appendChild(empty);
          return;
        }

        const filtered = itemTable.filter((item) => {
          if (!filter) return true;
          return (
            item.name.toLowerCase().includes(filter) ||
            (item.description || "").toLowerCase().includes(filter)
          );
        });

        if (!filtered.length) {
          const empty = document.createElement("div");
          empty.className = "weapon-option";
          empty.textContent = "No items match your search.";
          itemPickerList.appendChild(empty);
          return;
        }

        const list = document.createElement("div");
        list.className = "weapon-list";
        filtered
          .slice()
          .sort((a, b) => a.name.localeCompare(b.name))
          .forEach((item) => {
            const option = document.createElement("div");
            option.className = "weapon-option";
            if (item.name === itemSelected) {
              option.classList.add("selected");
            }
            option.addEventListener("click", () => {
              itemSelected = item.name;
              if (itemPickerAdd) {
                itemPickerAdd.disabled = false;
              }
              openInventoryItemPanel(item.name);
              buildItemPickerList(itemSearch?.value || "");
            });
            const name = document.createElement("strong");
            name.textContent = item.name;
            const meta = document.createElement("span");
            meta.textContent = `${formatGoldValue(item.goldValue)} | ${item.description || "No description"}`;
            option.appendChild(name);
            option.appendChild(meta);
            list.appendChild(option);
          });
        itemPickerList.appendChild(list);
      }

      function renderCantrips() {
        if (!cantripPanel) return;
        cantripPanel.innerHTML = "";
        if (!cantripItems.length) {
          const empty = document.createElement("div");
          empty.className = "spell-meta";
          empty.textContent = "No cantrips added.";
          cantripPanel.appendChild(empty);
          return;
        }

        const list = document.createElement("div");
        list.className = "spell-list";
        cantripItems.forEach((name) => {
          const spell = cantripByName.get(name);
          const row = document.createElement("div");
          row.className = "spell-item";

          const info = document.createElement("div");
          info.style.cursor = "pointer";
          const title = document.createElement("strong");
          title.textContent = name;
          info.appendChild(title);

          if (spell) {
            const meta = document.createElement("div");
            meta.className = "spell-meta";
            const metaParts = [spell.school, spell.range].filter(Boolean);
            meta.textContent = metaParts.join("  ");
            info.appendChild(meta);
          }

          info.addEventListener("click", () => {
            if (!spell) return;
            openSpellPanel(spell);
          });

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "spell-remove";
          removeBtn.textContent = "Remove";
          removeBtn.addEventListener("click", () => {
            cantripItems = cantripItems.filter((item) => item !== name);
            renderCantrips();
            scheduleSave();
          });

          row.appendChild(info);
          row.appendChild(removeBtn);
          list.appendChild(row);
        });

        cantripPanel.appendChild(list);
      }

      function initSpellPicker() {
        if (addSpellBtn) {
          addSpellBtn.addEventListener("click", () => {
            if (itemPanel) {
              itemPanel.classList.remove("open");
              itemPanel.setAttribute("aria-hidden", "true");
            }
            setSpellPickerOpen(true);
            buildCantripPickerList(spellSearch?.value || "");
          });
        }
        if (spellSearch) {
          spellSearch.addEventListener("input", () => {
            buildCantripPickerList(spellSearch.value);
          });
        }
        if (spellPickerAdd) {
          spellPickerAdd.addEventListener("click", () => {
            if (!cantripSelected) return;
            if (!cantripItems.includes(cantripSelected)) {
              cantripItems = [...cantripItems, cantripSelected];
              renderCantrips();
              scheduleSave();
            }
            if (itemPanel) {
              itemPanel.classList.remove("open");
              itemPanel.setAttribute("aria-hidden", "true");
            }
            setSpellPickerOpen(false);
          });
        }
        if (spellPickerClose) {
          spellPickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setSpellPickerOpen(false);
          });
        }
        if (removeSpellBtn) {
          removeSpellBtn.addEventListener("click", () => {
            if (!cantripItems.length) return;
            cantripItems = cantripItems.slice(0, -1);
            renderCantrips();
            scheduleSave();
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            setSpellPickerOpen(false);
          }
        });
        buildCantripPickerList("");
        renderCantrips();
      }

      function initItemPicker() {
        if (addItemBtn) {
          addItemBtn.addEventListener("click", () => {
            setItemPickerOpen(true);
            buildItemPickerList(itemSearch?.value || "");
          });
        }
        if (itemSearch) {
          itemSearch.addEventListener("input", () => {
            buildItemPickerList(itemSearch.value);
          });
        }
        if (itemPickerAdd) {
          itemPickerAdd.addEventListener("click", () => {
            if (!itemSelected) return;
            inventoryItems = [...inventoryItems, itemSelected];
            renderInventoryItems();
            scheduleSave();
            setItemPickerOpen(false);
          });
        }
        if (itemPickerClose) {
          itemPickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setItemPickerOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            setItemPickerOpen(false);
          }
        });
        buildItemPickerList("");
        renderInventoryItems();
      }

      function initRacePicker() {
        if (raceInput) {
          const openPicker = () => {
            setRacePickerOpen(true);
            if (raceInput.value && raceList.includes(raceInput.value)) {
              raceSelected = raceInput.value;
              if (racePickerAdd) {
                racePickerAdd.disabled = false;
              }
              const existing = raceByName.get(raceInput.value);
              if (existing) {
                openRacePanel(existing);
              }
            }
            buildRacePickerList(raceSearch?.value || "");
          };
          raceInput.addEventListener("click", openPicker);
          raceInput.addEventListener("focus", openPicker);
          raceInput.addEventListener("input", () => {
            if (raceByName.has(raceInput.value)) {
              applyRaceSelection(raceInput.value);
            }
          });
        }
        if (raceSearch) {
          raceSearch.addEventListener("input", () => {
            buildRacePickerList(raceSearch.value);
          });
        }
        if (racePickerAdd) {
          racePickerAdd.addEventListener("click", () => {
            if (!raceSelected || !raceInput) return;
            raceInput.value = raceSelected;
            applyRaceSelection(raceSelected, { promptForSize: true });
            scheduleSave();
            setRacePickerOpen(false);
          });
        }
        if (racePickerClose) {
          racePickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setRacePickerOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            setRacePickerOpen(false);
          }
        });
        buildRacePickerList("");
      }

      function initSizePicker() {
        if (sizePickerClose) {
          sizePickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setSizePickerOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            setSizePickerOpen(false);
          }
        });
      }

      function initAlignmentPicker() {
        if (alignmentPickerClose) {
          alignmentPickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setAlignmentPickerOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            setAlignmentPickerOpen(false);
          }
        });
      }

      function initAbilityPicker() {
        if (abilityPickerClose) {
          abilityPickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setAbilityPickerOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            setAbilityPickerOpen(false);
          }
        });
      }

      function initClassPicker() {
        if (classInput) {
          const openPicker = () => {
            setClassPickerOpen(true);
            if (classInput.value && classByName.has(classInput.value)) {
              classSelected = classInput.value;
              if (classPickerAdd) {
                classPickerAdd.disabled = false;
              }
              const existing = classByName.get(classInput.value);
              if (existing) {
                openClassPanel(existing);
              }
            }
            buildClassPickerList(classSearch?.value || "");
          };
          classInput.addEventListener("click", openPicker);
          classInput.addEventListener("focus", openPicker);
        }
        if (classSearch) {
          classSearch.addEventListener("input", () => {
            buildClassPickerList(classSearch.value);
          });
        }
        if (classPickerAdd) {
          classPickerAdd.addEventListener("click", () => {
            if (!classSelected || !classInput) return;
            classInput.value = classSelected;
            setClassPickerOpen(false);
            const entry = classByName.get(classSelected);
            if (entry) {
              openAbilityPickerForClass(entry);
            }
          });
        }
        if (classPickerClose) {
          classPickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setClassPickerOpen(false);
          });
        }
        if (classEquipmentApply) {
          classEquipmentApply.addEventListener("click", () => {
            if (!pendingClassEquipmentEntry) return;
            applyClassStartingEquipment(pendingClassEquipmentEntry);
            scheduleSave();
            setClassEquipmentOpen(false);
          });
        }
        if (classEquipmentClose) {
          classEquipmentClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setClassEquipmentOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            setClassPickerOpen(false);
            setClassEquipmentOpen(false);
          }
        });
        buildClassPickerList("");
      }

      function initBackgroundPicker() {
        if (backgroundInput) {
          const openPicker = () => {
            setBackgroundPickerOpen(true);
            if (backgroundInput.value && backgroundByName.has(backgroundInput.value)) {
              backgroundSelected = backgroundInput.value;
              if (backgroundPickerAdd) {
                backgroundPickerAdd.disabled = false;
              }
              const existing = backgroundByName.get(backgroundInput.value);
              if (existing) {
                openBackgroundPanel(existing);
              }
            }
            buildBackgroundPickerList(backgroundSearch?.value || "");
          };
          backgroundInput.addEventListener("click", openPicker);
          backgroundInput.addEventListener("focus", openPicker);
          backgroundInput.addEventListener("input", () => {
            if (backgroundByName.has(backgroundInput.value)) {
              const entry = backgroundByName.get(backgroundInput.value);
              if (entry) {
                openBackgroundPanel(entry);
              }
            }
          });
        }
        if (backgroundSearch) {
          backgroundSearch.addEventListener("input", () => {
            buildBackgroundPickerList(backgroundSearch.value);
          });
        }
        if (backgroundPickerAdd) {
          backgroundPickerAdd.addEventListener("click", () => {
            if (!backgroundSelected || !backgroundInput) return;
            backgroundInput.value = backgroundSelected;
            const entry = backgroundByName.get(backgroundSelected);
            setBackgroundPickerOpen(false);
            if (entry) {
              openBackgroundPanel(entry);
              openBackgroundConfig(entry);
            }
          });
        }
        if (backgroundPickerClose) {
          backgroundPickerClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setBackgroundPickerOpen(false);
          });
        }
        if (backgroundConfigApply) {
          backgroundConfigApply.addEventListener("click", () => {
            if (!pendingBackgroundEntry) return;
            applyBackgroundSelection(pendingBackgroundEntry);
            scheduleSave();
            setBackgroundConfigOpen(false);
          });
        }
        if (backgroundConfigClose) {
          backgroundConfigClose.addEventListener("click", (event) => {
            event.stopPropagation();
            setBackgroundConfigOpen(false);
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            setBackgroundPickerOpen(false);
            setBackgroundConfigOpen(false);
          }
        });
        buildBackgroundPickerList("");
      }

      function buildSheetPayload() {
        const payload = {};
        for (const el of fieldEls) {
          payload[el.id] = getFieldValue(el);
        }
        computedDisplayEls.forEach((el) => {
          if (el?.id) {
            payload[el.id] = getListValue(el);
          }
        });
        Object.values(abilityScores).forEach((el) => {
          if (el?.id) {
            payload[el.id] = getListValue(el);
          }
        });
        payload.equipmentItems = equipmentItems.slice();
        payload.inventoryItems = inventoryItems.slice();
        payload.cantripItems = cantripItems.slice();
        payload.equippedMainId = equippedMainId;
        payload.equippedOffhandId = equippedOffhandId;
        payload.equippedMainTwoHanded = equippedMainTwoHanded;
        payload.equippedArmorId = equippedArmorId;
        payload.equippedShieldId = equippedShieldId;
        payload.appliedBackgroundName = appliedBackgroundName;
        payload.appliedBackgroundAbilityBonuses = { ...appliedBackgroundAbilityBonuses };
        payload.appliedBackgroundSkillIds = appliedBackgroundSkillIds.slice();
        payload.appliedBackgroundInventoryNames = appliedBackgroundInventoryNames.slice();
        payload.appliedBackgroundEquipmentIds = appliedBackgroundEquipmentIds.slice();
        payload.pendingBackgroundAbilityMode = pendingBackgroundAbilityMode;
        payload.pendingBackgroundAbilityAssignments = pendingBackgroundAbilityAssignments.slice();
        payload.pendingBackgroundEquipmentChoice = pendingBackgroundEquipmentChoice;
        payload.appliedClassEquipmentName = appliedClassEquipmentName;
        payload.appliedClassInventoryNames = appliedClassInventoryNames.slice();
        payload.appliedClassEquipmentIds = appliedClassEquipmentIds.slice();
        return payload;
      }

      function saveLocalSheet(payload) {
        try {
          localStorage.setItem(LOCAL_SHEET_STORAGE_KEY, JSON.stringify(payload));
        } catch (error) {
          console.error("Failed to save local sheet", error);
        }
      }

      function applySheetData(data) {
        if (!data) {
          applyBaseDefaults();
          recalcDerived();
          return;
        }
        isRemoteUpdate = true;
        fieldEls.forEach((el) => {
          applyFieldValue(el, data[el.id]);
        });
        computedDisplayEls.forEach((el) => {
          if (el?.id && data[el.id] !== undefined) {
            setListValue(el, data[el.id]);
          }
        });
        Object.values(abilityScores).forEach((el) => {
          if (el?.id && data[el.id] !== undefined) {
            setListValue(el, data[el.id]);
          }
        });
        if (alignmentInput) {
          alignmentInput.disabled = !classInput?.value;
        }
        if (classInput?.value && classesLoaded) {
          const entry = classByName.get(classInput.value);
          if (entry) {
            applyClassSelection(entry, { rollHp: false });
          }
        }
        applyRaceSelection(raceInput?.value || "");
        if (Array.isArray(data.equipmentItems)) {
          equipmentItems = normalizeEquipmentItems(data.equipmentItems);
          equippedMainId = data.equippedMainId || "";
          equippedOffhandId = data.equippedOffhandId || "";
          equippedMainTwoHanded = Boolean(data.equippedMainTwoHanded);
          equippedArmorId = data.equippedArmorId || "";
          equippedShieldId = data.equippedShieldId || "";
          if (!equipmentItems.some((item) => item.id === equippedMainId)) {
            equippedMainId = "";
          }
          if (!equipmentItems.some((item) => item.id === equippedOffhandId)) {
            equippedOffhandId = "";
          }
          if (!equipmentItems.some((item) => item.id === equippedArmorId)) {
            equippedArmorId = "";
          }
          if (!equipmentItems.some((item) => item.id === equippedShieldId)) {
            equippedShieldId = "";
          }
          if (!equippedMainId) {
            equippedMainTwoHanded = false;
          } else {
            const mainItem = getEquippedWeaponById(equippedMainId);
            const mainWeapon = mainItem ? getWeaponData(mainItem.name) : null;
            if (!isVersatileWeapon(mainWeapon)) {
              equippedMainTwoHanded = Boolean(mainWeapon?.properties.includes("Two-Handed"));
            }
          }
          if (!equipmentItems.some((item) => item.name === activeWeaponName)) {
            activeWeaponName = equipmentItems[0]?.name || "";
          }
          updateActiveWeaponLabel();
          renderEquipment();
          appliedClassEquipmentIds = appliedClassEquipmentIds
            .filter((id) => equipmentItems.some((item) => item.id === id));
          appliedBackgroundEquipmentIds = appliedBackgroundEquipmentIds
            .filter((id) => equipmentItems.some((item) => item.id === id));
        }
        if (Array.isArray(data.cantripItems)) {
          cantripItems = normalizeCantripItems(data.cantripItems);
          renderCantrips();
        }
        if (Array.isArray(data.inventoryItems)) {
          inventoryItems = normalizeInventoryItems(data.inventoryItems);
          renderInventoryItems();
        }
        appliedBackgroundName = typeof data.appliedBackgroundName === "string"
          ? data.appliedBackgroundName
          : "";
        const incomingBonuses = data.appliedBackgroundAbilityBonuses;
        appliedBackgroundAbilityBonuses = {
          str: Number(incomingBonuses?.str) || 0,
          dex: Number(incomingBonuses?.dex) || 0,
          con: Number(incomingBonuses?.con) || 0,
          int: Number(incomingBonuses?.int) || 0,
          wis: Number(incomingBonuses?.wis) || 0,
          cha: Number(incomingBonuses?.cha) || 0,
        };
        appliedBackgroundSkillIds = Array.isArray(data.appliedBackgroundSkillIds)
          ? data.appliedBackgroundSkillIds.map((entry) => String(entry || "")).filter(Boolean)
          : [];
        appliedBackgroundInventoryNames = Array.isArray(data.appliedBackgroundInventoryNames)
          ? data.appliedBackgroundInventoryNames.map((entry) => String(entry || "")).filter(Boolean)
          : [];
        appliedBackgroundEquipmentIds = Array.isArray(data.appliedBackgroundEquipmentIds)
          ? data.appliedBackgroundEquipmentIds.map((entry) => String(entry || "")).filter(Boolean)
          : [];
        pendingBackgroundAbilityMode = Number.isFinite(Number(data.pendingBackgroundAbilityMode))
          ? Number(data.pendingBackgroundAbilityMode)
          : 0;
        pendingBackgroundAbilityAssignments = Array.isArray(data.pendingBackgroundAbilityAssignments)
          ? data.pendingBackgroundAbilityAssignments
            .map((entry) => normalizeAbilityKey(entry))
            .filter(Boolean)
          : [];
        pendingBackgroundEquipmentChoice = typeof data.pendingBackgroundEquipmentChoice === "string"
          ? data.pendingBackgroundEquipmentChoice
          : "A";
        appliedClassEquipmentName = typeof data.appliedClassEquipmentName === "string"
          ? data.appliedClassEquipmentName
          : "";
        appliedClassInventoryNames = Array.isArray(data.appliedClassInventoryNames)
          ? data.appliedClassInventoryNames.map((entry) => String(entry || "")).filter(Boolean)
          : [];
        appliedClassEquipmentIds = Array.isArray(data.appliedClassEquipmentIds)
          ? data.appliedClassEquipmentIds.map((entry) => String(entry || "")).filter(Boolean)
          : [];
        appliedClassEquipmentIds = appliedClassEquipmentIds
          .filter((id) => equipmentItems.some((item) => item.id === id));
        appliedBackgroundEquipmentIds = appliedBackgroundEquipmentIds
          .filter((id) => equipmentItems.some((item) => item.id === id));
        applyBaseDefaults();
        recalcDerived();
        isRemoteUpdate = false;
      }

      function loadLocalSheet() {
        try {
          const raw = localStorage.getItem(LOCAL_SHEET_STORAGE_KEY);
          if (!raw) return;
          const data = JSON.parse(raw);
          applySheetData(data);
        } catch (error) {
          console.error("Failed to load local sheet", error);
        }
      }

      function scheduleSave() {
        if (isRemoteUpdate) return;
        if (saveTimer) clearTimeout(saveTimer);
        saveTimer = setTimeout(async () => {
          const payload = buildSheetPayload();
          saveLocalSheet(payload);
          try {
            await setDoc(sheetRef, payload, { merge: true });
          } catch (error) {
            console.error("Failed to save sheet", error);
          }
        }, 300);
      }

      function renderRoll(data) {
        if (!data) {
          resultEl.textContent = "No rolls yet.";
          return;
        }
        resultEl.innerHTML = "";
        const who = data.by || "someone";
        const when = data.at ? new Date(data.at.seconds * 1000) : null;
        const time = when
          ? when.toLocaleTimeString("en-US", { hour: "2-digit", minute: "2-digit" })
          : "now";
        if (Array.isArray(data.parts)) {
          const header = document.createElement("div");
          header.textContent = `${data.label} (by ${who} at ${time})`;
          resultEl.appendChild(header);
          data.parts.forEach((part) => {
            const line = document.createElement("div");
            line.className = "roll-line";
            const left = document.createElement("span");
            const detail = part.detail ? ` (${part.detail})` : "";
            left.textContent = `${part.label}${detail}`;
            const right = document.createElement("span");
            right.textContent = part.value >= 0 ? `+${part.value}` : `${part.value}`;
            line.appendChild(left);
            line.appendChild(right);
            resultEl.appendChild(line);
          });
          const total = document.createElement("div");
          total.className = "roll-total";
          total.textContent = `Total: ${data.value}`;
          resultEl.appendChild(total);
          return;
        }
        if (data.roll !== undefined && data.mod !== undefined) {
          const header = document.createElement("div");
          header.textContent = `${data.label} (by ${who} at ${time})`;
          resultEl.appendChild(header);
          const line = document.createElement("div");
          line.className = "roll-line";
          line.textContent = `d20: ${data.roll} ${data.mod >= 0 ? "+" : ""}${data.mod}`;
          resultEl.appendChild(line);
          const total = document.createElement("div");
          total.className = "roll-total";
          total.textContent = `Total: ${data.value}`;
          resultEl.appendChild(total);
          return;
        }
        resultEl.textContent = `Last roll: ${data.value} (by ${who} at ${time})`;
      }

      onSnapshot(rollRef, (snap) => {
        renderRoll(snap.data());
      });

      loadLocalSheet();

      onSnapshot(sheetRef, (snap) => {
        const data = snap.data();
        applySheetData(data);
        if (data) {
          saveLocalSheet(buildSheetPayload());
        }
      });

      fieldEls.forEach((el) => {
        const evt = el.type === "checkbox" ? "change" : "input";
        el.addEventListener(evt, scheduleSave);
      });
      if (speedInput) {
        if ("value" in speedInput) speedInput.addEventListener("input", () => {
          if (currentRaceSpeed === "" || currentRaceSpeed === undefined) return;
          const lockedValue = String(currentRaceSpeed);
          if (getListValue(speedInput) !== lockedValue) {
            setListValue(speedInput, lockedValue);
          }
        });
      }
      if (backgroundInput) {
        backgroundInput.addEventListener("input", () => {
          buildCantripPickerList(spellSearch?.value || "");
        });
      }
      Object.values(abilityScores).forEach((el) => {
        if (el && "value" in el) {
          el.addEventListener("input", recalcDerived);
        }
      });
      if (levelEl && "value" in levelEl) {
        levelEl.addEventListener("input", recalcDerived);
      }
      levelDecreaseBtn?.addEventListener("click", () => adjustLevel(-1));
      levelIncreaseBtn?.addEventListener("click", () => adjustLevel(1));
      document.querySelectorAll(".list-item input[type='checkbox']").forEach((el) =>
        el.addEventListener("change", recalcDerived)
      );
      applyBaseDefaults();
      recalcDerived();
      async function initApp() {
        await loadWeapons();
        await loadArmors();
        await loadItems();
        await loadCantrips();
        await loadTraits();
        await loadRaces();
        await loadBackgrounds();
        await loadClasses();
        initEquipmentWeapons();
        initItemPicker();
        initRacePicker();
        initBackgroundPicker();
        initSizePicker();
        initSpellPicker();
        initAlignmentPicker();
        initAbilityPicker();
        initClassPicker();
        renderEquipment();
        renderInventoryItems();
        applyRaceSelection(raceInput?.value || "");
        if (classInput?.value) {
          const entry = classByName.get(classInput.value);
          if (entry) {
            applyClassSelection(entry, { rollHp: false });
          }
        }
      }
      initApp();

      if (rollBtn) {
        rollBtn.addEventListener("click", async () => {
          const value = Math.floor(Math.random() * 20) + 1;
          playDiceSound();
          resultEl.textContent = `Rolling... (${value})`;
          try {
            await setDoc(rollRef, {
              value,
              by: "anonymous",
              at: serverTimestamp(),
            });
          } catch (error) {
            resultEl.textContent = "Failed to roll. Check Firestore permissions.";
            console.error(error);
          }
        });
      }

      function rollD20WithParts(parts, label) {
        const roll = Math.floor(Math.random() * 20) + 1;
        playDiceSound();
        const total = parts.reduce((sum, part) => sum + part.value, roll);
        const localData = {
          roll,
          value: total,
          label,
          parts: [
            { label: "d20", value: roll },
            ...parts,
          ],
          by: "you",
          at: { seconds: Math.floor(Date.now() / 1000) },
        };
        renderRoll(localData);
        return setDoc(rollRef, {
          roll,
          value: total,
          label,
          parts: [
            { label: "d20", value: roll },
            ...parts,
          ],
          by: "anonymous",
          at: serverTimestamp(),
        }).catch((error) => {
          console.error("Failed to save roll", error);
        });
      }

      function setupRollables() {
        function isInteractiveTarget(target) {
          if (!(target instanceof HTMLElement)) return false;
          if (target.closest("input[type='checkbox']")) return true;
          if (target instanceof HTMLButtonElement) return true;
          if (target instanceof HTMLSelectElement) return true;
          if (target instanceof HTMLTextAreaElement) return true;
          if (target instanceof HTMLInputElement) {
            return !target.readOnly;
          }
          return false;
        }

        function bindKey(el, handler) {
          el.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              handler();
            }
          });
        }

        function bindRowRoll(row, handler) {
          row.classList.add("rollable-row");
          row.setAttribute("role", "button");
          row.setAttribute("tabindex", "0");
          row.addEventListener("click", (event) => {
            if (isInteractiveTarget(event.target)) return;
            handler();
          });
          bindKey(row, handler);
        }

        saveRows.forEach((row) => {
          const ability = row.dataset.ability;
          const label = row.querySelector("span");
          const checkbox = row.querySelector("input[type='checkbox']");
          const name = label?.textContent || `${ability.toUpperCase()} Save`;
          if (label) {
            label.classList.add("rollable");
          }
          const handler = () => {
            const base = computeAbilityMod(toNumber(getListValue(abilityScores[ability])));
            const mod = base + (checkbox?.checked ? toNumber(proficiencyBonusEl?.value) : 0);
            const parts = [{ label: `${ability.toUpperCase()} Mod`, value: base }];
            if (checkbox?.checked) {
              parts.push({ label: "Proficiency", value: toNumber(proficiencyBonusEl?.value) });
            }
            rollD20WithParts(parts, `${name} Save`);
          };
          bindRowRoll(row, handler);
          if (label) {
            label.addEventListener("click", (event) => {
              event.stopPropagation();
              handler();
            });
            bindKey(label, handler);
          }
        });

        skillRows.forEach((row) => {
          const ability = row.dataset.ability;
          const label = row.querySelector("span");
          const checkbox = row.querySelector("input[type='checkbox']");
          const name = label?.textContent || "Skill Check";
          if (label) {
            label.classList.add("rollable");
          }
          const handler = () => {
            const base = computeAbilityMod(toNumber(getListValue(abilityScores[ability])));
            const mod = base + (checkbox?.checked ? toNumber(proficiencyBonusEl?.value) : 0);
            const parts = [{ label: `${ability.toUpperCase()} Mod`, value: base }];
            if (checkbox?.checked) {
              parts.push({ label: "Proficiency", value: toNumber(proficiencyBonusEl?.value) });
            }
            rollD20WithParts(parts, `${name} Check`);
          };
          bindRowRoll(row, handler);
          if (label) {
            label.addEventListener("click", (event) => {
              event.stopPropagation();
              handler();
            });
            bindKey(label, handler);
          }
          if (checkbox) {
            checkbox.addEventListener("change", handler);
          }
        });
      }

      function setupAttackRoll() {
        if (!attackRollBtn) return;
        attackRollBtn.addEventListener("click", (event) => {
          event.preventDefault();
          try {
            const mainItem = getEquippedWeaponById(equippedMainId);
            if (!mainItem) {
              setEquipStatus("Equip a main weapon before rolling hit.");
              return;
            }
            const weaponName = mainItem.name;
            const weapon = weaponName ? getWeaponData(weaponName) : null;
            const ability = getWeaponAttackAbility(weapon);
            const abilityKey = ability === "finesse"
              ? (toNumber(getListValue(abilityMods.dex)) >= toNumber(getListValue(abilityMods.str)) ? "dex" : "str")
              : ability || "str";
            const abilityValue = toNumber(getListValue(abilityMods[abilityKey]));
            const parts = [{ label: `${abilityKey.toUpperCase()} Mod`, value: abilityValue }];
            if (weapon && isWeaponProficient(weapon)) {
              parts.push({ label: "Proficiency", value: toNumber(proficiencyBonusEl?.value) });
            }
            const label = weaponName ? `${weaponName} Hit` : "Hit Roll";
            rollD20WithParts(parts, label);
          } catch (error) {
            console.error("Failed to roll attack", error);
          }
        });
      }

      function setupInitiativeRoll() {
        if (!initiativeEl) return;
        const rollInitiative = () => {
          const dexMod = toNumber(getListValue(abilityMods.dex));
          const parts = [{ label: "DEX Mod", value: dexMod }];
          rollD20WithParts(parts, "Initiative");
        };
        initiativeEl.addEventListener("click", (event) => {
          event.preventDefault();
          rollInitiative();
        });
        initiativeEl.addEventListener("keydown", (event) => {
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            rollInitiative();
          }
        });
      }

      function openItemPanel(name) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody) return;
        const armor = getArmorData(name);
        if (armor) {
          itemPanelTitle.textContent = armor.name;
          itemPanelBody.innerHTML = "";
          const dexPart =
            armor.dexBonus?.allowed
              ? armor.dexBonus?.max === null
                ? "+ DEX"
                : `+ DEX (max ${armor.dexBonus.max})`
              : "";
          const rows = [
            ["Type", armor.type || "--"],
            ["AC", `${armor.baseAC || 0} ${dexPart}`.trim()],
            ["Strength Requirement", armor.strengthRequirement || "--"],
            ["Stealth", armor.stealthDisadvantage ? "Disadvantage" : "Normal"],
            ["Weight", armor.weightLb !== null && armor.weightLb !== undefined ? `${armor.weightLb} lb.` : "--"],
            ["Cost", armor.costGp !== null && armor.costGp !== undefined ? `${armor.costGp} gp` : "--"],
            ["Don Time", armor.donTimeMinutes !== null && armor.donTimeMinutes !== undefined ? `${armor.donTimeMinutes} min` : "--"],
            ["Doff Time", armor.doffTimeMinutes !== null && armor.doffTimeMinutes !== undefined ? `${armor.doffTimeMinutes} min` : "--"],
          ];
          rows.forEach(([label, value]) => {
            const row = document.createElement("div");
            row.className = "item-row";
            const strong = document.createElement("strong");
            strong.textContent = label;
            const val = document.createElement("div");
            val.textContent = value;
            val.className = "item-tooltip";
            val.setAttribute("data-tooltip", `${label}: ${value}`);
            row.appendChild(strong);
            row.appendChild(val);
            itemPanelBody.appendChild(row);
          });
          itemPanel.classList.add("open");
          itemPanel.setAttribute("aria-hidden", "false");
          return;
        }
        const weapon = getWeaponData(name);
        if (!weapon) return;
        const useTwoHands =
          weapon.name === getEquippedWeaponById(equippedMainId)?.name && equippedMainTwoHanded;
        const damageValue = useTwoHands
          ? `${getWeaponDamageDie(weapon, true)} ${weapon.damage.split(" ").slice(1).join(" ")}`
          : weapon.damage;
        const [dice, ...typeParts] = (damageValue || "").split(" ");
        const damageType = typeParts.join(" ");
        const ability = getWeaponAttackAbility(weapon);
        const abilityLabel =
          ability === "finesse" ? "Finesse (STR/DEX)" : ability.toUpperCase();
        const rangeMatch = weapon.properties.match(/Range\\s*([0-9/]+)/i);
        const rangeValue = rangeMatch ? rangeMatch[1] : null;
        itemPanelTitle.textContent = weapon.name;
        itemPanelBody.innerHTML = "";
        const rows = [
          ["Category", weapon.category.replace(" Weapons", "")],
          ["Type", weapon.category.includes("Ranged") ? "Ranged" : "Melee"],
          ["Damage", dice || ""],
          ["Damage Type", damageType || ""],
          ["Attack Ability", abilityLabel],
          ["Properties", weapon.properties === "" ? "None" : weapon.properties],
          ["Mastery", weapon.mastery || ""],
          ["Weight", weapon.weight || ""],
          ["Cost", weapon.cost || ""],
        ];
        if (rangeValue) {
          rows.splice(4, 0, ["Range", rangeValue]);
        }
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          val.setAttribute("data-tooltip", getItemTooltip(label, value, weapon));
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      function openSpellPanel(spell) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody || !spell) return;
        itemPanelTitle.textContent = spell.name || "Spell";
        itemPanelBody.innerHTML = "";
        const levelLabel = formatSpellLevel(spell.level);
        const rows = [
          ["Level", levelLabel || ""],
          ["School", spell.school || ""],
          ["Range", spell.range || ""],
          ["Components", spell.components || ""],
          ["Duration", spell.duration || ""],
          ["Classes", (spell.classes || []).join(", ") || ""],
          ["Description", spell.description || ""],
        ];
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          val.setAttribute("data-tooltip", getSpellTooltip(label, value));
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      function getClassTooltip(label, value) {
        if (label === "Subclasses") {
          return Array.isArray(value) && value.length
            ? `Subclasses: ${value.join(", ")}.`
            : "No subclasses listed.";
        }
        if (label === "Description") {
          return value || "No description.";
        }
        return `${label}: ${value || "--"}`;
      }

      function openClassPanel(entry) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody || !entry) return;
        itemPanelTitle.textContent = entry.name || "Class";
        itemPanelBody.innerHTML = "";
        const subclassNames = entry.subclasses.map((sub) => sub.name).filter(Boolean);
        const rows = [
          ["Description", entry.description || "--"],
          ["Primary Ability", entry.primaryAbility.join(", ") || "--"],
          ["Hit Die", entry.hitPointDie || "--"],
          ["Hit Die Modifier", entry.hitPointDieModifier || "--"],
          ["HP per Level", entry.hitPointPerAdditionalLevelDie || "--"],
          ["Saving Throws", entry.savingThrows.join(", ") || "--"],
          ["Weapon Proficiencies", entry.weaponProficiencies.join(", ") || "--"],
          ["Armor Training", entry.armorTraining.join(", ") || "--"],
          ["Starting Equipment", entry.startingEquipment.join(", ") || "--"],
          ["Subclasses", subclassNames.join(", ") || "--"],
        ];
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          val.setAttribute("data-tooltip", getClassTooltip(label, label === "Subclasses" ? subclassNames : value));
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      function getRaceTooltip(label, value) {
        if (label === "Traits") {
          return Array.isArray(value) && value.length
            ? `Traits: ${value.join(", ")}.`
            : "No traits listed.";
        }
        if (label === "Description") {
          return value || "No description.";
        }
        return `${label}: ${value || "--"}`;
      }

      function getBackgroundTooltip(label, value) {
        if (label === "Ability") {
          return value || "No ability options.";
        }
        if (label === "Feat") {
          return value || "No feat listed.";
        }
        if (label === "Skills") {
          return value || "No skills listed.";
        }
        if (label === "Tools") {
          return value || "No tools listed.";
        }
        if (label === "Equipment") {
          return value || "No equipment listed.";
        }
        return `${label}: ${value || "--"}`;
      }

      function openBackgroundPanel(entry) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody || !entry) return;
        itemPanelTitle.textContent = entry.name || "Background";
        itemPanelBody.innerHTML = "";
        const abilityModes = getBackgroundAbilityModes(entry)
          .map((mode) => mode.weights.map((weight) => `+${weight}`).join(" / "))
          .join(" or ");
        const feats = extractBackgroundFeatNames(entry);
        const skills = extractBackgroundSkillNames(entry);
        const tools = extractBackgroundToolNames(entry);
        const equipSet = entry.startingEquipment?.[0] || {};
        const equipRows = Object.keys(equipSet).map(
          (key) => `${key}: ${summarizeEquipmentChoice(equipSet[key] || [])}`
        );
        const rows = [
          ["Ability", abilityModes || "--"],
          ["Feat", feats.join(", ") || "--"],
          ["Skills", skills.join(", ") || "--"],
          ["Tools", tools.join(", ") || "--"],
          ["Equipment", equipRows.join(" | ") || "--"],
        ];
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          val.setAttribute("data-tooltip", getBackgroundTooltip(label, value));
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      function openRacePanel(entry) {
        if (!itemPanel || !itemPanelTitle || !itemPanelBody || !entry) return;
        itemPanelTitle.textContent = entry.name || "Race";
        itemPanelBody.innerHTML = "";
        const sizes = normalizeRaceSizes(entry.size);
        const traits = Array.isArray(entry.traits) ? entry.traits.slice() : [];
        const types = Array.isArray(entry.creatureType) ? entry.creatureType.slice() : [];
        const subclasses = Array.isArray(entry.subclass) ? entry.subclass.slice() : [];
        const rows = [
          ["Description", entry.description || "--"],
          ["Creature Type", types.join(", ") || "--"],
          ["Size", sizes.join(", ") || "--"],
          ["Speed", normalizeRaceSpeed(entry.speed) !== "" ? String(entry.speed) : "--"],
          ["Traits", traits.join(", ") || "--"],
          ["Subraces", subclasses.join(", ") || "--"],
        ];
        rows.forEach(([label, value]) => {
          const row = document.createElement("div");
          row.className = "item-row";
          const strong = document.createElement("strong");
          strong.textContent = label;
          const val = document.createElement("div");
          val.textContent = value;
          val.className = "item-tooltip";
          const tooltipValue = label === "Traits" ? traits : value;
          val.setAttribute("data-tooltip", getRaceTooltip(label, tooltipValue));
          row.appendChild(strong);
          row.appendChild(val);
          itemPanelBody.appendChild(row);
        });
        itemPanel.classList.add("open");
        itemPanel.setAttribute("aria-hidden", "false");
      }

      function setupItemPanel() {
        if (!itemPanel || !itemPanelClose) return;
        itemPanelClose.addEventListener("click", (event) => {
          event.stopPropagation();
          itemPanel.classList.remove("open");
          itemPanel.setAttribute("aria-hidden", "true");
        });
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            itemPanel.classList.remove("open");
            itemPanel.setAttribute("aria-hidden", "true");
          }
        });
      }

      setupRollables();
      setupAttackRoll();
      setupInitiativeRoll();
      setupItemPanel();
      console.log("Firebase initialized", app.name);
    </script>
  </body>
</html>
